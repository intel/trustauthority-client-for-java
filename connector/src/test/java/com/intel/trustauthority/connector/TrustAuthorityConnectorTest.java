/*
 *   Copyright (c) 2023-2024 Intel Corporation
 *   All rights reserved.
 *   SPDX-License-Identifier: BSD-3-Clause
 */
package com.intel.trustauthority.connector;

// JUnit imports for assertions and test annotations
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

// MockServer imports for HTTP server mocking
import org.mockserver.client.MockServerClient;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.HttpResponse;

// Base64 utility import
import com.nimbusds.jose.util.Base64;

// Mockito imports for mocking objects and defining behavior
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.mock;
import static org.mockito.ArgumentMatchers.any;

// Utility imports
import java.io.ByteArrayInputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.cert.X509CRL;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.UUID;

// Log4j imports for logging
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

// Nimbus JOSE+JWT library import for JWT claims set
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jose.jwk.JWKSet;

/**
 * TrustAuthorityConnectorTest contains unit tests for all APIs exposed by the TrustAuthorityConnector
 */
public class TrustAuthorityConnectorTest {

    // Logger object
    private static final Logger logger = LogManager.getLogger(TrustAuthorityConnectorTest.class);

    // Initialize Mock Server object
    private ClientAndServer mockServer;

    // Initialize Config and TrustAuthorityConnector
    private Config cfg;
    private TrustAuthorityConnector connector;

    // Declare jwks samples
    String validJwks;
    String invalidJwks;
    String leafVerificationFailureJWKS;
    String intermediateVerificationFailureJWKS;
    String rootVerificationFailureJWKS;

    // Declare token samples
    String validToken;
    String invalidToken;
    String tokenWrongKid;
    String tokenInvalidKid;
    String tokenMissingKid;
    String tokenInvalidAlg;

    // Declare cert/crl samples
    String invalidCertHex;
    String invalidCACertHex;
    String crlHex;
    String validCertHex;
    String validInterCaCertHex;
    String outdatedCrlHex;
    String certNoDistributionPoints;

    @Before
    public void setup() {
        try {
            // Setup Mock Server
            mockServer = new ClientAndServer(); // No-args constructor will start on a free port

            // Default RetryConfig
            RetryConfig retryConfig = new RetryConfig(2, 2, 2);

            // Initialize config required for connector
            cfg = new Config("http://localhost:" + mockServer.getPort(),
                             "http://localhost:" + mockServer.getPort(),
                             "some_key", retryConfig);
            assertNotNull(cfg);

            // Initializing connector with the config
            connector = new TrustAuthorityConnector(cfg);
            assertNotNull(connector);

            // Verify connector config
            assertEquals(connector.getConfig(), cfg);
            
            // token samples for testing
            validToken = "eyJhbGciOiJQUzM4NCIsImprdSI6Imh0dHBzOi8vYW1iZXItdGVzdDEtdXNlcjEucHJvamVjdC1hbWJlci1zbWFzLmNvbS9jZXJ0cyIsImtpZCI6IjFhMWEyZmU1ZmNmODkwMDllNGI5NmM0NWUwZGNlYjAwNWVhNjM1ZDhiYTJmNmVkOWNhZWVmNDRhZTIzNTk3MGRlY2M1ODYxNTRmZDlmNzQwZmIzYjcyY2ExNzZhYmI1OSIsInR5cCI6IkpXVCJ9.eyJzZ3hfbXJlbmNsYXZlIjoiMGE3NTZhNjUzYjlhOTJiMTNkYmQ2MjRhNWE1OTY4MTU4OTViMTMwODIwYzU1ZjNiMWI3Y2FmYjMwNDY5NjViYyIsInNneF9tcnNpZ25lciI6ImQ0MTJhNGYwN2VmODM4OTJhNTkxNWZiMmFiNTg0YmUzMWUxODZlNWE0Zjk1YWI1ZjY5NTBmZDRlYjg2OTRkN2IiLCJzZ3hfaXN2cHJvZGlkIjowLCJzZ3hfaXN2c3ZuIjowLCJzZ3hfcmVwb3J0X2RhdGEiOiI0MDE4OWU5YmRiZmRjMzA5OWEwZmE3MzVlYTEyNjkwZDI3MTEyZGUyOWRkYjgxNDFkMGNhYzMzMGNjM2FiYjE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInNneF9pc19kZWJ1Z2dhYmxlIjpmYWxzZSwic2d4X2NvbGxhdGVyYWwiOnsicWVpZGNlcnRoYXNoIjoiYjJjYTcxYjhlODQ5ZDVlNzk5NDUxYjRiZmU0MzE1OWEwZWU1NDgwMzJjZWNiMmMwZTQ3OWJmNmVlM2YzOWZkMSIsInFlaWRjcmxoYXNoIjoiZjQ1NGRjMWI5YmQ0Y2UzNmMwNDI0MWUyYzhjMzdhMmFlMjZiMDc3ZjJjNjZiOTE5ODQzMzY1MzE4YTU5MzMyYyIsInFlaWRoYXNoIjoiOTk1ZDljMmUyYmVhNzYyOWEzMmI2NWUxMmZmZjc1MzJkM2M2YTc2YWFmODEwYjgwZTg5Y2RjNjE4YTJmYTVjOSIsInF1b3RlaGFzaCI6IjViMzJhMWUyZmJjOTdlNTJjZWMxNDgxZTg5ZTNmMmFmYmFjM2QzMDZmMDE5ZTBiYTA3OTAwNGM0ZWM0MzRlNTMiLCJ0Y2JpbmZvY2VydGhhc2giOiJiMmNhNzFiOGU4NDlkNWU3OTk0NTFiNGJmZTQzMTU5YTBlZTU0ODAzMmNlY2IyYzBlNDc5YmY2ZWUzZjM5ZmQxIiwidGNiaW5mb2NybGhhc2giOiJmNDU0ZGMxYjliZDRjZTM2YzA0MjQxZTJjOGMzN2EyYWUyNmIwNzdmMmM2NmI5MTk4NDMzNjUzMThhNTkzMzJjIiwidGNiaW5mb2hhc2giOiI3M2UwYzhkNDU2ODdhMTU2YzUyNzQ1YmRlOWJkMDRkZGU2MTcxY2YzMjFmNDA3NDE5Zjg0MGU5YmJhYzY1ZTAxIn0sImF0dGVzdGVyX2hlbGRfZGF0YSI6IkFRQUJBQjBuQ1RNR3dXOXdtYy93M3dKSGwraDRnODJwMGQ4aWpGU3ZuT2JBdTBEb3pWdHR2d3NweEJRK1ZCdXMvNDhJQVBLQnhmV3owcjYybWNjeHJWMTRndFJaWU9RWHBXUnNPeUF3cHJoNndqWHlHdmtrbDNuVEQ0a0Y0L29WZ1NVaUlwZDZMcjFxUVd6a2N0bnhoWHpkWkxpVWp3TktPNHdIaFdoV1hVNEduSEl4SmQwVUtiQXIyM2lPNGRrSnkxY3dmNUZxd0pROVI2L3UrYW1vLzI0QkZDQUNLamZhbHNpaThXendtSE5UQ3hNeWtGOE0zWEwrTjJCSFdsVlNOa21VLzFSMlp2eFk2V3pQRUpsbGkwVHhySWJwaG1SdHpKM3E2cDdPSktPT2dXKzFCdkxtcUd4K05ZL2xqNjQvRXJOKzBZTVZLNGI3ZU05ZTFIVS9qQ0JRVlpvTnM1LzB1ZUgyOGpjZTJBSituWWUyUFc0R2hXallueklaYnZNTy9QKy9RR3NvRXJlZ2RsQ0c3ZWVvMUZxV1dtdUt0S3N3RStwRmFXbmQwMFJOZ29qMU81anJERmJMM0RpTVYwTGNVOTU5Q3BjV2lkN1VKYmlEUTM1OUgrVVhXZmpNdVJ3aE0yanJhaE9nczd2dFdtWUcrcnZEb0dTS29DQVBQNVhlNlRoU3lBPT0iLCJ2ZXJpZmllcl9ub25jZSI6eyJ2YWwiOiJWV2N3V1hCbmIwdGtiSEJ6YXpaVlZITTBPVGRGWVdoM01Wb3JkVmhHU0VaSlFXVXdTMXBpTXpOVlREa3dlVkl2WTJnemVsRkZkRGx5UVdZM1dYZHhia1ptWWtRMU9WZE5MMnB6VW5GeE1HVnBSRTlZVUVFOVBRPT0iLCJpYXQiOiJNakF5TXkweE1pMHlNU0F3TlRvek1Ub3dPQ0FyTURBd01DQlZWRU09Iiwic2lnbmF0dXJlIjoiVXAyZlluNUhwcTVpbXRmeXZmaWZEQisrbjV2bVVhcXZydU9kQVVtckg4OG5JRWorQU94NXk1ck5sV1BqWkNWcnk1emxpcjVOdUVNa0ZJc2FQV1pJM0t1L2ozQlZNM081dk0yOGJFR3lSYTA2V2phQWtLbktLZ3hrK3NaMG54RVluUGxuTGtweW81YjVKbXBEOFJOWm5iL2d2OXBYaWVxZU1OYThnTStkK2pwMk90M0VqUzR1VmhUYllSYmdxamJ6VlBhNEYrTVgrbnUzR01FSmdKdFlvZnFtZnRHa25mc1VHdW1BVE12Z21NdVV4Vk1lSFhQUUFGd1I4RWJrTE1odzlxOUVyVU1YdTB1Z045cTdsd2QrNUJKZ1pGR0lyeWNWZTRudzJGTVZITzI5SHdlMzM0czdQZ002SEpQR3NpaDN2S3dNVXM4SSt0MWVnUDRzcjJERWJPblZlS254VFdwV1IraUNqZks0NmJicE80VS9GYmN4c0k2SXAxK3ZvOVd5WDBCQVpFSmpuWHpMZGYydHZVRnJjcmJ1dFVYWW1xaWd5dks5SmtpcWltR29JQ3ptYjZuc25wSmJOeFlDK3RNY1FtUFk0ekgva2x2K3p3N0FVZnZvUXFpRG13UmtDYUgvcTRNdmNsKzBwUkwrUFUrbkdidkpHZHJHNk9LVSt2T2UifSwicG9saWN5X2lkc19tYXRjaGVkIjpbeyJpZCI6IjkxNDg4ZTEyLWYzOWUtNGYzZS04NDM1LWQ0OWM4MTNkZWNiNSIsInZlcnNpb24iOiJ2MSJ9XSwicG9saWN5X2lkc191bm1hdGNoZWQiOlt7ImlkIjoiN2YzODE0MzAtNTFmOC00N2IwLWE2ZTAtMzkzZWYxODM3YWYzIiwidmVyc2lvbiI6InYxIn1dLCJwb2xpY3lfZGVmaW5lZF9jbGFpbXMiOnt9LCJhdHRlc3Rlcl90Y2Jfc3RhdHVzIjoiT3V0T2ZEYXRlIiwiYXR0ZXN0ZXJfdGNiX2RhdGUiOiIyMDIxLTExLTEwVDAwOjAwOjAwWiIsImF0dGVzdGVyX2Fkdmlzb3J5X2lkcyI6WyJJTlRFTC1TQS0wMDU4NiIsIklOVEVMLVNBLTAwNjE0IiwiSU5URUwtU0EtMDA2MTUiLCJJTlRFTC1TQS0wMDY1NyIsIklOVEVMLVNBLTAwNzMwIiwiSU5URUwtU0EtMDA3MzgiLCJJTlRFTC1TQS0wMDc2NyIsIklOVEVMLVNBLTAwODI4IiwiSU5URUwtU0EtMDA4MzciXSwiYXR0ZXN0ZXJfdHlwZSI6IlNHWCIsInZlcmlmaWVyX2luc3RhbmNlX2lkcyI6WyI5YTRlMjQ2OS03NGIwLTQ4OWQtOTczYi1jMTU0NzllODNhZDEiLCIxNDc2ZGE3NC0yOTdkLTRiYzEtYjdkMi0xMGUyNTk1MGJhN2MiLCJjMTQyMTcyNi1lYjViLTRmYWEtYmEzOC0zNWZiMGM3ZDk1NDYiLCI4NGNmZGUzYi0wM2Q1LTQ4ZWYtYTIxMC0xZWY5ZTU2MTE2YTMiXSwiZGJnc3RhdCI6ImRpc2FibGVkIiwiZWF0X3Byb2ZpbGUiOiJodHRwczovL2FtYmVyLXRlc3QxLXVzZXIxLnByb2plY3QtYW1iZXItc21hcy5jb20vZWF0X3Byb2ZpbGUuaHRtbCIsImludHVzZSI6ImdlbmVyaWMiLCJ2ZXIiOiIxLjAuMCIsImV4cCI6MTcwMzEzNjk2OCwianRpIjoiOGViNDg2NmMtNTc0Ni00YzdkLWJlNzktM2UwNDlkYzBhNzQ5IiwiaWF0IjoxNzAzMTM2NjY4LCJpc3MiOiJJbnRlbCBUcnVzdCBBdXRob3JpdHkiLCJuYmYiOjE3MDMxMzY2Njh9.tf9oqTHuJKA8LPcqqHndNgLlc7GxCkNx3TerIbHU9OpzoU6pEnbcDo8655p3X1LUQQ1yb-fi5IqRZYO8-KCnsCCAuID8ff4bGwBKCExN0xP656tLbh3w7dyh7miIuJz9JBVvDn41CPKcRotuzoMjMIQzQQiIBaU4bRBDEWHaMEHoGM8qr0KXqz0YP3kKT1f4fL7FAKHjSyxNqqw3_bxFaeFvEBcTCnRBgEUAIxd79Yq0LndDenxAkfEaXOmtCSd_t9-vs7zzBKvbZ_wurVnXQbLaLM8DEMzykZmTB5yIERbrfFzkR-61Uv3cibWGdR8Be0shc3pgvgcXtSKaPsLdNI7pf17S0fCEMwCKtIBStHcDVbyz8fvDHnW8lUsHXHWY4hrXJfTfH0DnoISJCXpXoLLr43D8wAd4PLdUOzaQ0tMYRtCnsWW5lzvpReHzD13GjgCb_2T1KutxR6a9QidIbAAi8i1EUwmvjlloQyPwV0neC5Gczetd79zHHNRrDjpW";
            tokenWrongKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.O1YS3tK9moRRMCLkqWloLHIJ_F-NfpfQVFLo4mq3ui4HCgQLAK7bELjHl__igbzF6zTOLd3fwaoCKeVF1DDwBBoPhMXkAjZQMaNBFz8xZghQZfkSJLiMygyrkzSqgzLFMOgdBJaqcKxWT-cbO3JyAmG4sbxxFo8Lh5foVCmzF88aqfX0MPvUuiQG9aNVvJFqj2gW9hTSB3ljhxeRqZhTSQcpEkE67Xpr70rcdXaLbK-Ab4gw9YrW4aMHqR1aeLWg-s1OTosRpJGKLQ90BqWUJSx1QCmzRbAsEOfUeIK2CSwD0miUw6aSR2tVQcj0peZ2T-1xr8j0UFHRGCo5iLyAGBrHuNZ5c3fPL_xygwAkGKSkaO22d0NLRjauNeMKwT16BqZvZdN050AhfkMrwPa6AxQeJC__uBiIScKWK5ZSJJP3ba0_LHCsnnAOVZJMdD0uGdvzwXLhCTT44yeGVRbmw6KvLKjwLLotEsXY6M84rtMYnP16XeenidMH0-5YoaNOkFMR987qV-q2yXRemEHdH4KzmoBnMPtlvTSi1XW4jTM7bgziPEEK44mfZC_bkHKQnEWT51whYOPgcWYwYfjBm0oMoPKeCuIbHU6tMceGqZTsAzaWUSSlti_jVmQFR6Pp22w1d7BY-TGKDDG_wK4adj4n_KoGw5_HFYwoQfb6G_o";
            tokenInvalidKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6MTIzNH0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.lsBarFSfZNLtmTJyKfcnxqoU80QTx2PJHU0cl4esXIi64iD0C0h_B2TobIfkcUHIDNnkwcmZmik9dMxQaKU59qW6yUPgN9GcglD6RpgrJ4StHaOpfJvWY6TtsuSdcWlG33wc9RhcZ4PXV4pdYx5210e0PRgGAPelyq0MvdZa1IpZUnssQulMrk6OJNs3L-7ZfI5ZQFmJyWMzWcY7HQ9Nk2vfjaYtChfmKCSVdbyrDjtzsSDY9r5bYMI5pUCxXl30RSiEYv8fOBpYB_TJPxHyC0VaYtYVLIl4ZzUzG5VS4ragjJVXZZkX1tcDSpTakmgMbcvT1aqyJ9iVGJKSzfPovht-HxYlnmPysQPgeYY4LMywlRW8RJned9ZmKZ4F5Y8aTAUWdO4_ruBL0u8Z7J8-BTGkvNUgBUx9c7p_uy1dt7MTQkDW7d6sjP89xoNHnz4z4w7erAEuBEaPrknmYokpIdqf-esynBtW4NfIKyfl-_PGJnngPn7ziBNuTqxzq0sgTdovX8nxwal3LeWVtXx6HzN5CIRcR7BpDNC5jRhsyZ0U-p4D9Iic63KXMQLhkMx3D0vxzpzlT_zhkvw-kqXNsp6sIN3XqwlZjNTX6lptjV_OXnpVgJ8pb5svURGbwWcFIDJlgaYkHn7jLHnnaKz1aaHQezClod6_vbEPyjcfrsI";
            tokenMissingKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.IO_z9EOfF9e2noXDva33D8D2y9CS8Tf9lmB-w7cK5DNawk0r66RrjmY-jk6p8MIha126nniMRI7UZaeSSrfzwwuYVZCD35X7xRqhsRz5mpVkoluooXENIVvE4F8UVpY4yewgB6JXvFFplqaXWCSoQ8GxmwHXnHwEzS_W0df5VqTTBilRtgEEbwqBnANWWVkzm89ZX9d2ebkgow5dG9O-ra0SNhO_-66a4b78wvhiE_dw-99pnYbU-XLUwqVEu1Nk4sMW9jp7Y7d0f_WR9uOcB4SvojVJBTGc9cuCBjDI8g2zYyFs04exifYF7SQiofn1KodR5FDwOUiNwQfC-isnwa9fpKPOuGXEOJm6FBCK7cYrpP0JQrOv3IVeIh1Qix3N6-sF_TfUWgzBZlolvaf98msky8Yv0udyL0rkKMUUStV48R4TTChuAtpxoSu1Fr-sdMhWf76xGHvXjTUL_W4TZA8a3GyxLHawbcXez-Sk357djVol5xDIVAZU3ORpT4RuwPBKaoodEBSSWnFlP0l577Y7J8St0_UdGCyg8TMt2MBjaah1EJRDLOiXw_C0_Efa0rid6HbKlzwhlk6BzXQbnxdRoFBnh2KcsewQMMKfVtv3_nFxvgyiMTgdXY1lbmmVJ9rmEJlVyzCdfLoZavSrBwl5xkGipr657fmZ2Tbe6j0";
            invalidToken = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjNmZDc1MWYyZTBkMGY1Mjg0NmMwZWNkNDk3MmM2ZTk5ZGZjNjQyMDUxY2QzMzlkZDliMDQzODFhZjhjMGRkYjgwNDUxNGE3YTFmZWU0NjczYWM4NDRmZDVkYjdmMTVmYiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.tJPT6hz2psdkB2yuf17UjqcH1t4ujt9iwRP8iFrG93vMZN2W8umIlYVCE9NVigYoX3EkNuOq_OGlYvfdrUjsYFU-hFLvmORLbaBZ2u0GCfxgrGpYX7ngjZRad_cE9KGcmv6R2fxWI4gF-73DMeaoGWXTVAPlquV_Tyc987zeXj1KXAVO0SDWG68LiWVcl42FUlOI_2mXV4rGsgWLPgbyaa5SuSu-ENreQenvyUMMzdntbJtytQycOxYVrppQJaFNKwn8OfwloGvt7jedylCZgU1MBIrTXUN_lgKAZnFfRxUMfbiV-i73kPqWcOAxbzK8JZPAKv4AyVDWFEBhKKuxiQ";
            tokenInvalidAlg = "eyJhbGciOiJIUzM4NCIsImprdSI6Imh0dHBzOi8vYW1iZXItdGVzdDEtdXNlcjEucHJvamVjdC1hbWJlci1zbWFzLmNvbS9jZXJ0cyIsImtpZCI6IjFhMWEyZmU1ZmNmODkwMDllNGI5NmM0NWUwZGNlYjAwNWVhNjM1ZDhiYTJmNmVkOWNhZWVmNDRhZTIzNTk3MGRlY2M1ODYxNTRmZDlmNzQwZmIzYjcyY2ExNzZhYmI1OSIsInR5cCI6IkpXVCJ9.eyJzZ3hfbXJlbmNsYXZlIjoiMGE3NTZhNjUzYjlhOTJiMTNkYmQ2MjRhNWE1OTY4MTU4OTViMTMwODIwYzU1ZjNiMWI3Y2FmYjMwNDY5NjViYyIsInNneF9tcnNpZ25lciI6ImQ0MTJhNGYwN2VmODM4OTJhNTkxNWZiMmFiNTg0YmUzMWUxODZlNWE0Zjk1YWI1ZjY5NTBmZDRlYjg2OTRkN2IiLCJzZ3hfaXN2cHJvZGlkIjowLCJzZ3hfaXN2c3ZuIjowLCJzZ3hfcmVwb3J0X2RhdGEiOiI0MDE4OWU5YmRiZmRjMzA5OWEwZmE3MzVlYTEyNjkwZDI3MTEyZGUyOWRkYjgxNDFkMGNhYzMzMGNjM2FiYjE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInNneF9pc19kZWJ1Z2dhYmxlIjpmYWxzZSwic2d4X2NvbGxhdGVyYWwiOnsicWVpZGNlcnRoYXNoIjoiYjJjYTcxYjhlODQ5ZDVlNzk5NDUxYjRiZmU0MzE1OWEwZWU1NDgwMzJjZWNiMmMwZTQ3OWJmNmVlM2YzOWZkMSIsInFlaWRjcmxoYXNoIjoiZjQ1NGRjMWI5YmQ0Y2UzNmMwNDI0MWUyYzhjMzdhMmFlMjZiMDc3ZjJjNjZiOTE5ODQzMzY1MzE4YTU5MzMyYyIsInFlaWRoYXNoIjoiOTk1ZDljMmUyYmVhNzYyOWEzMmI2NWUxMmZmZjc1MzJkM2M2YTc2YWFmODEwYjgwZTg5Y2RjNjE4YTJmYTVjOSIsInF1b3RlaGFzaCI6IjViMzJhMWUyZmJjOTdlNTJjZWMxNDgxZTg5ZTNmMmFmYmFjM2QzMDZmMDE5ZTBiYTA3OTAwNGM0ZWM0MzRlNTMiLCJ0Y2JpbmZvY2VydGhhc2giOiJiMmNhNzFiOGU4NDlkNWU3OTk0NTFiNGJmZTQzMTU5YTBlZTU0ODAzMmNlY2IyYzBlNDc5YmY2ZWUzZjM5ZmQxIiwidGNiaW5mb2NybGhhc2giOiJmNDU0ZGMxYjliZDRjZTM2YzA0MjQxZTJjOGMzN2EyYWUyNmIwNzdmMmM2NmI5MTk4NDMzNjUzMThhNTkzMzJjIiwidGNiaW5mb2hhc2giOiI3M2UwYzhkNDU2ODdhMTU2YzUyNzQ1YmRlOWJkMDRkZGU2MTcxY2YzMjFmNDA3NDE5Zjg0MGU5YmJhYzY1ZTAxIn0sImF0dGVzdGVyX2hlbGRfZGF0YSI6IkFRQUJBQjBuQ1RNR3dXOXdtYy93M3dKSGwraDRnODJwMGQ4aWpGU3ZuT2JBdTBEb3pWdHR2d3NweEJRK1ZCdXMvNDhJQVBLQnhmV3owcjYybWNjeHJWMTRndFJaWU9RWHBXUnNPeUF3cHJoNndqWHlHdmtrbDNuVEQ0a0Y0L29WZ1NVaUlwZDZMcjFxUVd6a2N0bnhoWHpkWkxpVWp3TktPNHdIaFdoV1hVNEduSEl4SmQwVUtiQXIyM2lPNGRrSnkxY3dmNUZxd0pROVI2L3UrYW1vLzI0QkZDQUNLamZhbHNpaThXendtSE5UQ3hNeWtGOE0zWEwrTjJCSFdsVlNOa21VLzFSMlp2eFk2V3pQRUpsbGkwVHhySWJwaG1SdHpKM3E2cDdPSktPT2dXKzFCdkxtcUd4K05ZL2xqNjQvRXJOKzBZTVZLNGI3ZU05ZTFIVS9qQ0JRVlpvTnM1LzB1ZUgyOGpjZTJBSituWWUyUFc0R2hXallueklaYnZNTy9QKy9RR3NvRXJlZ2RsQ0c3ZWVvMUZxV1dtdUt0S3N3RStwRmFXbmQwMFJOZ29qMU81anJERmJMM0RpTVYwTGNVOTU5Q3BjV2lkN1VKYmlEUTM1OUgrVVhXZmpNdVJ3aE0yanJhaE9nczd2dFdtWUcrcnZEb0dTS29DQVBQNVhlNlRoU3lBPT0iLCJ2ZXJpZmllcl9ub25jZSI6eyJ2YWwiOiJWV2N3V1hCbmIwdGtiSEJ6YXpaVlZITTBPVGRGWVdoM01Wb3JkVmhHU0VaSlFXVXdTMXBpTXpOVlREa3dlVkl2WTJnemVsRkZkRGx5UVdZM1dYZHhia1ptWWtRMU9WZE5MMnB6VW5GeE1HVnBSRTlZVUVFOVBRPT0iLCJpYXQiOiJNakF5TXkweE1pMHlNU0F3TlRvek1Ub3dPQ0FyTURBd01DQlZWRU09Iiwic2lnbmF0dXJlIjoiVXAyZlluNUhwcTVpbXRmeXZmaWZEQisrbjV2bVVhcXZydU9kQVVtckg4OG5JRWorQU94NXk1ck5sV1BqWkNWcnk1emxpcjVOdUVNa0ZJc2FQV1pJM0t1L2ozQlZNM081dk0yOGJFR3lSYTA2V2phQWtLbktLZ3hrK3NaMG54RVluUGxuTGtweW81YjVKbXBEOFJOWm5iL2d2OXBYaWVxZU1OYThnTStkK2pwMk90M0VqUzR1VmhUYllSYmdxamJ6VlBhNEYrTVgrbnUzR01FSmdKdFlvZnFtZnRHa25mc1VHdW1BVE12Z21NdVV4Vk1lSFhQUUFGd1I4RWJrTE1odzlxOUVyVU1YdTB1Z045cTdsd2QrNUJKZ1pGR0lyeWNWZTRudzJGTVZITzI5SHdlMzM0czdQZ002SEpQR3NpaDN2S3dNVXM4SSt0MWVnUDRzcjJERWJPblZlS254VFdwV1IraUNqZks0NmJicE80VS9GYmN4c0k2SXAxK3ZvOVd5WDBCQVpFSmpuWHpMZGYydHZVRnJjcmJ1dFVYWW1xaWd5dks5SmtpcWltR29JQ3ptYjZuc25wSmJOeFlDK3RNY1FtUFk0ekgva2x2K3p3N0FVZnZvUXFpRG13UmtDYUgvcTRNdmNsKzBwUkwrUFUrbkdidkpHZHJHNk9LVSt2T2UifSwicG9saWN5X2lkc19tYXRjaGVkIjpbeyJpZCI6IjkxNDg4ZTEyLWYzOWUtNGYzZS04NDM1LWQ0OWM4MTNkZWNiNSIsInZlcnNpb24iOiJ2MSJ9XSwicG9saWN5X2lkc191bm1hdGNoZWQiOlt7ImlkIjoiN2YzODE0MzAtNTFmOC00N2IwLWE2ZTAtMzkzZWYxODM3YWYzIiwidmVyc2lvbiI6InYxIn1dLCJwb2xpY3lfZGVmaW5lZF9jbGFpbXMiOnt9LCJhdHRlc3Rlcl90Y2Jfc3RhdHVzIjoiT3V0T2ZEYXRlIiwiYXR0ZXN0ZXJfdGNiX2RhdGUiOiIyMDIxLTExLTEwVDAwOjAwOjAwWiIsImF0dGVzdGVyX2Fkdmlzb3J5X2lkcyI6WyJJTlRFTC1TQS0wMDU4NiIsIklOVEVMLVNBLTAwNjE0IiwiSU5URUwtU0EtMDA2MTUiLCJJTlRFTC1TQS0wMDY1NyIsIklOVEVMLVNBLTAwNzMwIiwiSU5URUwtU0EtMDA3MzgiLCJJTlRFTC1TQS0wMDc2NyIsIklOVEVMLVNBLTAwODI4IiwiSU5URUwtU0EtMDA4MzciXSwiYXR0ZXN0ZXJfdHlwZSI6IlNHWCIsInZlcmlmaWVyX2luc3RhbmNlX2lkcyI6WyI5YTRlMjQ2OS03NGIwLTQ4OWQtOTczYi1jMTU0NzllODNhZDEiLCIxNDc2ZGE3NC0yOTdkLTRiYzEtYjdkMi0xMGUyNTk1MGJhN2MiLCJjMTQyMTcyNi1lYjViLTRmYWEtYmEzOC0zNWZiMGM3ZDk1NDYiLCI4NGNmZGUzYi0wM2Q1LTQ4ZWYtYTIxMC0xZWY5ZTU2MTE2YTMiXSwiZGJnc3RhdCI6ImRpc2FibGVkIiwiZWF0X3Byb2ZpbGUiOiJodHRwczovL2FtYmVyLXRlc3QxLXVzZXIxLnByb2plY3QtYW1iZXItc21hcy5jb20vZWF0X3Byb2ZpbGUuaHRtbCIsImludHVzZSI6ImdlbmVyaWMiLCJ2ZXIiOiIxLjAuMCIsImV4cCI6MTcwMzEzNjk2OCwianRpIjoiOGViNDg2NmMtNTc0Ni00YzdkLWJlNzktM2UwNDlkYzBhNzQ5IiwiaWF0IjoxNzAzMTM2NjY4LCJpc3MiOiJJbnRlbCBUcnVzdCBBdXRob3JpdHkiLCJuYmYiOjE3MDMxMzY2Njh9.uDFxPnguPV1RGkF_486k9n0MDSti7rduYMbQKwH88SAdhBiiOp13NYx1qiOGa0-1";

            // crl/cert samples for testing
            invalidCertHex = "30820557308203bfa003020102020102300d06092a864886f70d01010d0500305b310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3123302106035504030c1a496e74656c20416d62657220415453205369676e696e67204341301e170d3233303431303137343732355a170d3233313030373137343732355a3060310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3128302606035504030c1f416d626572204174746573746174696f6e20546f6b656e205369676e696e6730820222300d06092a864886f70d01010105000382020f003082020a0282020100b833bb7f44d9a1521bf304c78b4080e3688d82c9fb5a8e9c513f314e7eeb4b87e92dfd04f029e96206a4a249e777c266fd69868dbc62d824261fa1c5656f811ea67b035155e806a75b858de937b65d0b9f2312d1bab91eb84697e064bee5fe63f5717c8aca3d50e075f1a8e8284f7cfee324a18060c9189bc1f92daf72cc8475151c1244e39513d8339aeb2cdcb39665065138356bdfc1c008e8ed382894fc662300b2caffcd52c06e739d7f5533414a7578b664156953d6b260dea206c8b59a02f60968d813bf75a8a0d8fb73f16d08bfcc88ec708da44ac7b6a227c81ff5e053439345f4a4e99fb0f2846630aab22123143486a705855113e81ba1aef52c31875a492f4dc1114be9254b2c86f2827c938add6ff35b5e112e7149132964abb2e4aabbf438cac65947ff38c171338be9323ecb1b101d0c2d6f38d6cb774de752c20f19569deb6f040943eb855225ca143de4265c8d199dec1f7f6d06b4dd6382ce22101f139533175972254bd782ad1f83e2ed3294611c6a9307cbe4d79e0db1b71e3bcee64f8af3ee5d0da52eb3ff9de4e0bc76e79c2cd5e58c5699bd8d755dad9ebe6f40a1c64e806c52ed7ee9bfe1e87f993d7d37cc7ef37d56aed50ba41dcecd52f35e83fa6b34d0ed6bc438c9a2e520f674977577856552b5f53ed9ba3083a92f81533d61d7321a3b355b8869c93a777661b635abf72395fb8f736ab7130203010001a381a030819d300c0603551d130101ff04023000301d0603551d0e04160414e4ddc5bd96e128a82465cb26e1bce1990d587898301f0603551d230418301680143bd92d080eb2c16881832d0d7436dc926e59c743300b0603551d0f0404030204f030400603551d1f043930373035a033a031862f5552493a68747470733a2f2f616d6265722e696e74656c662e636f6d2f6174732d7369676e696e672d63612e70656d300d06092a864886f70d01010d050003820181004279fb07bc3f336be663c838761dddb8ce5f7d28ae38800a707c4eb11c39434cb96fd741070ed1cb7becca26ab075deeb23667cfd533918fd3ccae394de3cc1ee07c800a0cb2ac7355beeb825a9a7fd791e63e8a058f260a7bf4bed9a1001154b3b9935fcc92f473aa86f933bc91e31677c4b5e08224e67e0b473ef8e82252a8430d6feec4cfd40ba0a64788346d29e1464f7e9cd497dcd35e6b561f8993d664f9d1cb08db555bd5510297cb766b7db0f032ab6ee57a495e485f87fc78fb5312948856b3c0c62b8056dc1308b40faf5bcc2fafdc871e464fb05398f4d47d35a9b39c0fdcb74ccea38bc41a821037a8e30190e998865fa8f0ae714aa4145e981a1601909eba2a9f5cd9584c7a4ae160396a692aa33d8fd686fe951e41d8ab14d01534c12477a5fae4ac715f4ee75da1e38f1689dfee2f4596da9ec069f000e80bb750a6aa2993bd049c1423ce1b677f5a7b6d28a962227507761acc156413d88baaf3bb3cb3c570aedbb11a7cb12f8329739abc44541d9d2811f0407816324433";
            invalidCACertHex = "308204c53082032da003020102021436441d9104098f2aa434e0c9d36db2ce0cf80828300d06092a864886f70d01010d0500306a311c301a06035504030c13496e74656c20416d62657220526f6f74204341310b3009060355040613025553310b300906035504080c0243413114301206035504070c0b53616e746120436c617261311a3018060355040a0c11496e74656c20436f72706f726174696f6e301e170d3233303431303137343732315a170d3439313233303137343732315a306a311c301a06035504030c13496e74656c20416d62657220526f6f74204341310b3009060355040613025553310b300906035504080c0243413114301206035504070c0b53616e746120436c617261311a3018060355040a0c11496e74656c20436f72706f726174696f6e308201a2300d06092a864886f70d01010105000382018f003082018a0282018100caaef4384fe8e11855f33557e7d6a9bbba6e578eaba2f6f883e1582ba44b3da4a0980512a29e59b8c07a554488a11183aa94ee84a3540f4d9995431189c476e8e62ca83914c243916384a31a59c0a8b647931cfb7455927164d51071942754e286e9792b176396a18138d44b944fc73263a1d0064b723298802c81bf7a5fd1a4a773a328c687b3c050e7395929879ad5fd8b31e64e581b6015e38ab6aa511b3ac4b703e6a2d622fd4d21748694081294038cec2b0a2122addb78e8247e67ff4ce4c1ac93c1db2f24d2ac857cef6d431817d01360eec2249fb00e29a7195f72ab8b9ada0a8d09b571c666ab70c93a265a54e5fbba330cd53abf62091f42a7fe55da41c7ba0735865941fb65a4e2c714b3c6b1bb3822947e6263fbfd4c1f6e9d15d7d4b94cf6dcd0868a966a823c2dd41aee7c7c74c1fa3f12c7ead3032559f751065fa13664adf4db057f4810f52b41009c79e57535cbc268300e2addbd342efce224f2d87a47db89ba31fee519b873044e40abacfb3cb503cc75ac63b5e732550203010001a3633061300f0603551d130101ff040530030101ff301d0603551d0e04160414de4aa628f84dc5e960d5a850207fa684acfe7a56301f0603551d23041830168014de4aa628f84dc5e960d5a850207fa684acfe7a56300e0603551d0f0101ff040403020106300d06092a864886f70d01010d05000382018100774792455f8ff0e45605d3b4edbf744563a3cebaf93a29116d5b585b5e74134ade6524be5652d72e4cc57e535f9639747f9dd15f252d3423cf1f0dfa0516c8c219e6d7ee9a9859977cfc5f81e887da7f1e12f52a43bb093c01350e4c25dea4795a208bc883960d5c29cc5a016864c6e0ccb275257b43e3e0b549dd5c6181a50802413676d1887ba2b1df8dcf3d7918d46187fdf0b5a4c52b2613af55c3bf57af8c619e73801084a9ffaa302ecf0fd31fa423025b3fa9cf88debcaf798eb3ecf188dd7d3362d476de168e533689ec32e67d4dc94a10d1eb2492b020fa72fa1c700baad9be5917f81ae9e8775c1b8c9f19127048b93d5bfbf201ad19ce462e1f85bf81d7e79fe5521071e9abe6b11dea7540a2bc89791b0f09354068b5466d2bd2f0a23aad44b54e1114ad8ae61b9615f76bd120d431e0494bcbd6750f5d6444b79e6bd0163c4a83dd312ebd55cdd63d1aacd808ab5155012d22ea15ec40dcbc6a69643d2ffe4fd970abe003e9f54e26a7234c8df9a972a7104b14675b8e8e3129";
            crlHex = "3082023a3081a3020101300d06092a864886f70d01010d05003061310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3129302706035504030c20446576656c6f706d656e7420416d62657220415453205369676e696e67204341170d3234303133313037303732315a170d3234303330313037303732315aa00e300c300a0603551d140403020107300d06092a864886f70d01010d050003820181005a0aed71b4acbd5884018e404f4968a57d4edc40164a9b85b5fbd803215ad788224682ff27a20d563e9695fc7b15cb6a9d225ac9df022e7ab98d9782ef02e232a788f5b0b9251f182cc03b2bea6dc9d9050a47d0c07d4725437c37a4ca4e405ad48c4343304ed75bb2f8795a45d81cbbd464ce0e929a095e6eb84a4b5b5c86c5ef8dab368b3523a641c027ae1e78ec27f75f14e8826c3f6d47afd06fe17af9d7ae3f0754372ea04de2ad8069145a32ff6897b377879a07931027630c9a87168edab485ce059814bad2a4c13c2b1fc7c84466c33116d66daa5617d66dcd822d39be9e24fb44797bebe60c16313b484e4926d98218040feaf8d23d43cc1b5d401514ca840b39fa338eda619b91f4fe44f604f016896f2483b66164bd4fca87028d7dcebe3a1a74b1b172a6bcc9a497f2556e152976e3a28e5d9d24c2a61ea335b781e4875af9f56ab4dda78e183bda71e688c4e75a575aeda23dd6091d6104263e47498309cd5770fdf23407bcf89ed14c38dc05ecd113d000165e56350450c2dd";
            validCertHex = "308204fd30820365a003020102020101300d06092a864886f70d01010d05003061310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3129302706035504030c20446576656c6f706d656e7420416d62657220415453205369676e696e67204341301e170d3233303731393130333533305a170d3234303731383130333533305a306c310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3134303206035504030c2b446576656c6f706d656e7420416d626572204174746573746174696f6e20546f6b656e205369676e696e67308201a2300d06092a864886f70d01010105000382018f003082018a0282018100bca295eefedccce1daa50db66675baefb8b8064408bb15532e4f77de36af7d9c8bce933b64ffcc86fbbd42a1ebafe88a12a08306e5f5b252ff8680747d30861a7a054d9d654ea05d9a1172b08820e6ecc0a8c58bd9225dcd85fd449fd95cc167bf34f39cef9bda325df3ae29508eb2ef69abcdf4ea42f830ffad1f6b7b6373dce324f8aa4f5c9a74a6abdc6e5cd1f26a83b014a284ee32422adbdd6d1eaa0d85f633cec859092155fdde51aee85e54c8ef80cba7c75cc84a267944d463732dfd1bbfb4f144c222548a13f19db0b0cd5621ea002cfad015b7a7e91263961da2c9702af0d43899e455932924d7dd603a0122220680a2f68f91fc6ab1e6852c35035925eba61d0e5ec7e4f6b8eaaa7807616b4b9429b750fd0be4995e458ddf0cc32102ec1cab347bce91e60b8b312f7f59c7ec3c270708b8ea3197ba4bed7c49d8f0cc22b885b9f9bcb099614cc8c951087184fc7f7992decdc8d54c49456e775993842a4c8654a2864c5f2e4716a4b05546ac8756d10e355a8de6077d0ddada8b0203010001a381b43081b1300c0603551d130101ff04023000301d0603551d0e04160414e3438a503a68d6ea320a839c369486879668b1ef301f0603551d230418301680145ef57a01cede8c0de3eb65738656c696f083d62b300b0603551d0f0404030204f030540603551d1f044d304b3049a047a045864368747470733a2f2f616d6265722d74657374312d75736572312e70726f6a6563742d616d6265722d736d61732e636f6d2f63726c2f6174732d63612d63726c2e646572300d06092a864886f70d01010d0500038201810045c6f717f172f8a9ce80d4fd51f16ca4588c2c5df77ff9f1327596d1f3fe72f0fb6f9a4fdd47d1b2c665186e8789853f3a22dc3bd44f1fdf4c771caadb85bea117d1d904cd5afd812556f06921905d750b1a7ffd92812e0f935723d427c10f2e0fe5b2a80085c9ad1540ebcca91fbd619f80db75ff9f17b267ac415df8296950b585973a9071cc512a0c921540287c78467c8a35d55222b71da7ec67961a75f6fad13d21db96d049e7a36604acc96bf2ef6af5953e5c64960b7a3b0d59ed02b807b0f2f6745200b7db4c586b3070fd00b1a9acde6ec699b9ea83431fe2d71c30950b9d4ea94a2fae14ab9032138eab671ad5ac1fc3f93b0786080b75d64bd273c7ebc91d902d5916c409d6a65c100b7743c8c9db624596ac846d2a13d11b47f915c1413177c6504c34689d171dc9bd83148badcda17c6ec7942b90078c265eee85cd82d0e3b4315d1e737cd0f97e98bd58dc18a1c2787266fa3e4b91c5ff0be1979c46d82024dc27c931b8eda88bb032be24737ba9a627a1ca35f295b5e6f7d8";
	        validInterCaCertHex = "3082050b30820373a003020102020101300d06092a864886f70d01010d050030703122302006035504030c19446576656c6f706d656e7420416d62657220526f6f74204341310b3009060355040613025553310b300906035504080c0243413114301206035504070c0b53616e746120436c617261311a3018060355040a0c11496e74656c20436f72706f726174696f6e301e170d3233303731393130333330335a170d3336313233303130333330335a3061310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3129302706035504030c20446576656c6f706d656e7420416d62657220415453205369676e696e67204341308201a2300d06092a864886f70d01010105000382018f003082018a0282018100ab0bbd2049cd589fd35aaff8aa52fc49fa6900e0bfc02068d064b161416f5d71d4288182cd34532f178db467cc07d26896b4fe5c6154143856f0db8d1f6eee4017b8a4a7eac3af88324a07eaa206c627599a2c4ce69440fd57d58c952d8478427b0163bf0f90bf5b86a6955e6fab241d7ccbe54af7b3d49abf777d1970f29b374af9e86bc583c005f96e06ed76010aca33ecd076bfcc8d3e3c6063b9d270c40dc610a950b4c8f68c9775ae296d0a56af5d9243721dcc56ba3457fc936843c79e4395e1cc14e64af79a929507fb97425801009d7ad9d15b32f01237b40d417d1f490089a34596bac5c955af4a541b0ff0fb2e59b156238aa91b91eaaabad8ebf9504353067ced3833783c2c4b30c6a067c4846876547a14a69a4a7fac128d9fe7fc082661c5f1cfa248e62dcff210a2a1cc46e0c97a1f361a94ff1f96e8160ea3d1cb101116d054a23532636dcd7ca14c3a3c2e23c0177a505527e4e8e365a9d7e1395a52e40fdb2195cfcd03e2e9fd21e636924c6051bef580de5bb12e27dd890203010001a381be3081bb30120603551d130101ff040830060101ff020100301d0603551d0e041604145ef57a01cede8c0de3eb65738656c696f083d62b301f0603551d230418301680147473398c6a2ea8875fa9d288fe779c688ef7af0e300e0603551d0f0101ff04040302010630550603551d1f044e304c304aa048a046864468747470733a2f2f616d6265722d74657374312d75736572312e70726f6a6563742d616d6265722d736d61732e636f6d2f63726c2f726f6f742d63612d63726c2e646572300d06092a864886f70d01010d05000382018100a165aa1b338be48e0c53daa9677a79962fc2a4d49f174a508ca58a1f885b59c123a7e8332cd8d7f8caaf9e74b7dd57ad1e35293431f4e441246758ba64bf18b7571d97abe1ef19aaaa0127eb42f3bfc4d6ee8f6c62140a5eeb36cb2d25df05927b0be458297320e3166709742fe1690dd57ba1eed950e45d8905cfe9d2819de29ad8017ad09453379ddfa79534769ba9b18795d85eb117194fcdda32a866335cf30091d4ce1b3e12f67c3747b870882657f082ddcc7fc6acdf75d014b937e23c2e0676b35f39ded1852e0a4935354e88143dba5661acbb10cdde0fd0c7b1bdf840c69fb72994d602a69d696ea0020b440d77cd26d4cc9a100e072e9503fd738a5649b2dad7e888a1768dbe12b07cb7bdcdd7b321e01180c2f81480d5dd87b1fe2f3a25a30fd8011d40cb8e1e7b4fb39779d1a147a706ab6e37b9d8560114ead3bb02076a505311bf8435ac8154c58710b128e4a33138a18bfd1d9ebf313d664c9a013809f6c041a4a5f654bc74ecce81adea20a5ebf560a6a8fc7b545872a235";
            outdatedCrlHex = "308202733082019BA00302010202101A33F17D9823D118C740AC0D300D06092A864886F70D0101050500307D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464301E170D3230303430313030303030305A170D3230303430343132303030305A307D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464308181310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464304D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C746430819F300D06092A864886F70D010101050003818D0030818902818100B93D383F609DE79C2C9F0C2A49C1FAED7F84C97EEA4ADBA9D1CE53D847CDC1564899F36B0502C81BFD8ABD0D0517D1C140D0572D79A4E38C4A0F0D362E17A119E36011C12C36249E0F9D8D617352A882C5A28C3C8A1F01A8D0991C78FB7D3B9973B756C0B0D8D7B5EAE704831E72195D3A3FBEB1449E7D50F5202010001300D06092A864886F70D010105050030818D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C746430819F300D06092A864886F70D010101050003818D0030818902818100B93D383F609DE79C2C9F0C2A49C1FAED7F84C97EEA4ADBA9D1CE53D847CDC1564899F36B0502C81BFD8ABD0D0517D1C140D0572D79A4E38C4A0F0D362E17A119E36011C12C36249E0F9D8D617352A882C5A28C3C8A1F01A8D0991C78FB7D3B9973B756C0B0D8D7B5EAE704831E72195D3A3FBEB1449E7D50F5202010001300D06092A864886F70D0101050500";
            certNoDistributionPoints = "-----BEGIN CERTIFICATE-----\nMIIDwTCCAqmgAwIBAgIgbVqgQF+vioHzCJNn3ui4+hyQyu1+9P0IHlglQFPKUbUw\nDQYJKoZIhvcNAQEFBQAwdjEOMAwGA1UEBhMFQmxvcmUxDTALBgNVBAoMBElOVEMx\nDTALBgNVBAsMBElOVEMxEjAQBgNVBAMMCWR1bW15LmNvbTEeMBwGCSqGSIb3DQEJ\nARYPZHVtbXlAZHVtbXkuY29tMRIwEAYDVQQDDAlkdW1teS5jb20wHhcNMjQwMjA3\nMDUxNDM1WhcNMzQwMjA3MDUxNDM1WjBiMQ4wDAYDVQQGEwVCbG9yZTENMAsGA1UE\nCgwESU5UQzENMAsGA1UECwwESU5UQzESMBAGA1UEAwwJZHVtbXkuY29tMR4wHAYJ\nKoZIhvcNAQkBFg9kdW1teUBkdW1teS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCSx0idbSH3MycmDgbcQuI/6LRRIcdpNnvLLTLHU0sRz63J3sYX\nSX/gF0UgAFocZlZAny69t7RJ9N7wvQ6jUMTjvKjdqxXEzmNf9gjS38t8cB5ikRAm\nC+3Xt5fBLy1XzvrjUFVBcevUw+Y+oJ0clLknHNCVJTKLkQPxRHUleVaV3wC5YB7R\nF+XQVfUsu3mJzRrA13WGjtF2KmLsgaEX/SuCHi0QcGBapo8U8y8y3gV72DEpqIVx\nigl+iduxlhNQAaUMiD6WPs0jAVc1cP8ah+jq/+U9SJ5Bp7faMiThGsxmm8oVvOD5\nZw5DeCFfy8sSTI98IlHsOqBnk8w1tXQpUCbTAgMBAAGjTzBNMB0GA1UdDgQWBBT4\n156vh9jLxF0z631dkgTUMtKYnTAfBgNVHSMEGDAWgBT4156vh9jLxF0z631dkgTU\nMtKYnTALBgNVHREEBDACggAwDQYJKoZIhvcNAQEFBQADggEBAI/B3SbP4s9gTiMj\nSyvXpgvZVpYX+HH5rIptOylgD4xSVgBIFUP7G1barfUS6ClackCfrmRso9WmO45N\nPSgDe4R0QPEOthIAmy3or0tGGjaj35TRzaWDfgQLIa1mB3hmLXpMWppf5FY3sPjs\noLQVHW+KwQPyWNZl8u2CjSyzj8PaAa3rJqCIlQDp+UsWH8UhOIAogU53HFpNaWYT\nEnnN7+U5TmCKxi3ciksXq9GZ0cOz3WBo0L2/GQjz56rQUv8jVb5KmJ6h2M9EKXOE\nxe18NNZB0qaBTFpboNmWWmbe67/NupWEQmHHgjRiy7MlnvTsrFXdl3f/Y2qhvri/\nKW43J1c=\n-----END CERTIFICATE-----";

            // jwks samples for testing
            validJwks = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            invalidJwks = "{\"keys\":[{\"kty\":\"RSA\",\"kid\":\"example-key-1\",\"use\":\"sig\",\"alg\":\"RS512\",\"n\":\"p7-56CwfyqLldDQ7d0C0ZFQTL2e9mz_1iHbBTV6p4I8R2tlqsh4DVdS6ilxf_FWe_HlnXq1Nkx-_z1miSZhRg_kHPjtbcvxGRoKBKqBcXhUdVY7xFsD9m6W6z6h9dN6OXJ0NQY0DzGtmRTD_yuQFgYUn8KosdREH-Pp8w-fgfr3r5Q\",\"e\":\"AQAB\",\"d\":\"G3psHvef3HzarQUGryEP4kP8x8nOh9GfM2R8YOTsKpyY9aYtHxFuiPks8fvW8RyyPDTnzZ-_6RUvZYN3WEDF0Y-XbwrlM78KmmhYtEvQajOhLprW4W4hJpxITf1qOxgjA62RVa1Op2_A2LDRj7XqfZ9JoPB0IlnugBx9OuP7_kFmE\",\"p\":\"_qkjLJlRg_ZXr9ifM3URrTD00mVW8U35s5RZWdhEmy9eGU7mjQjsoiVif3nquV7BrzETXyH5UdH9xxV2yjprHw\",\"q\":\"xlqm_LueqqOQBWx-3VlbiqQs47ShJ7xwANU2cvh9eNifnJWOTlnqHLW-k9wZJnXCZSM3p1JQXgtN7lfcgGRI5Ww\",\"dp\":\"PnIInZSoMltzLy3YyNL0s4F8v33EhRO3KW9rsy5sfiC-3DpSszCwFvF3KH4RpN5y2efR4iaCk7NKId24qARh8w\",\"dq\":\"JF8-9bRfb9mYERQYdOi-ALQDn4pVN84Fv0FhJhBqE5myaY6smhxQGw-o0m6yxCz3rpX_2tQ2R-2vxcrvdbEuyQ\",\"qi\":\"RSBFDqKwnF16Ig56pUP02xUw6fKLhU13rGf9Lh3K0gGZ4M9Jufc4sZKyL9ZgNdtfNUvHrL4d6IbY99Y6mI9JpQ\"}]}";
            leafVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            intermediateVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            rootVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";

        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @After
    public void tearDown() {
        // Shut down Mock Server after tests are run
        mockServer.stop();
    }

    @Test
    public void testConstants() {
        Constants constants = new Constants();
        assertEquals(Constants.HEADER_X_API_KEY, "x-api-key");
        assertEquals(Constants.HEADER_ACCEPT, "Accept");
        assertEquals(Constants.HEADER_CONTENT_TYPE, "Content-Type");
        assertEquals(Constants.HEADER_REQUEST_ID, "request-id");
        assertEquals(Constants.HEADER_TRACE_ID, "trace-id");
        assertEquals(Constants.MIME_APPLICATION_JSON, "application/json");
    }

    @Test
    public void testConfig() {
        try {
            // Default RetryConfig
            RetryConfig retryConfig = new RetryConfig(0, 0, 0);

            // Initialize config
            Config config = new Config("http://localhost:" + mockServer.getPort(),
                                       "http://localhost:" + mockServer.getPort(),
                                       "some_key",
                                       retryConfig);
            assertNotNull(config);

            // Test connector config setter
            TrustAuthorityConnector conn = new TrustAuthorityConnector(config);
            conn.setConfig(config);
            assertEquals(conn.getConfig(), config);

            // Testing getters for Config
            assertEquals(config.getBaseUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiKey(), "some_key");

            // Testing setters for Config
            config.setBaseUrl("http://localhost:" + mockServer.getPort());
            config.setApiUrl("http://localhost:" + mockServer.getPort());
            config.setApiKey("some_key");
            assertEquals(config.getBaseUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiKey(), "some_key");

            // Testing getters/setters for RetryConfig
            RetryConfig customRetryConfig = new RetryConfig(2, 10, 3);
            config.setRetryConfig(customRetryConfig);
            config.getRetryConfig().setRetryWaitMin(2);
            config.getRetryConfig().setRetryWaitMax(10);
            config.getRetryConfig().setRetryMax(3);
            assertEquals(config.getRetryConfig().getRetryWaitMin(), 2);
            assertEquals(config.getRetryConfig().getRetryWaitMax(), 10);
            assertEquals(config.getRetryConfig().getRetryMax(), 3);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testTokenRequest() {
        try {
            // Create mock objects for testing
            byte[] expected = {1, 2, 3, 4, 5};
            byte[] actual = {1, 2, 3, 4, 5};
            String expectedTokenSigningAlg = "mock-token-signing-algo";
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Initialize TokenRequest
            TokenRequest token_request = new TokenRequest(expected, mockNonce, expected, mockPolicyIDs, expected, expectedTokenSigningAlg);

            // Testing setters for TokenRequest
            token_request.setQuote(expected);
            token_request.setVerifierNonce(mockNonce);
            token_request.setRuntimeData(expected);
            token_request.setPolicyIds(mockPolicyIDs);
            token_request.setEventLog(expected);
            token_request.setTokenSigningAlg(expectedTokenSigningAlg);
            assertArrayEquals(token_request.getQuote(), actual);
            assertEquals(token_request.getVerifierNonce(), mockNonce);
            assertArrayEquals(token_request.getRuntimeData(), actual);
            assertEquals(token_request.getPolicyIds(), mockPolicyIDs);
            assertArrayEquals(token_request.getEventLog(), actual);
            assertEquals(token_request.getTokenSigningAlg(), expectedTokenSigningAlg);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testEvidence() {
        try {
            // Create mock objects for testing
            byte[] expected = {1, 2, 3, 4, 5};
            byte[] actual = {1, 2, 3, 4, 5};
            long expected_type = 0;

            // Initialize Evidence
            Evidence evidence = new Evidence(expected_type, expected, expected, expected);

            // Testing getters for Evidence
            assertEquals(evidence.getType(), 0);
            assertArrayEquals(evidence.getQuote(), actual);
            assertArrayEquals(evidence.getUserData(), actual);
            assertArrayEquals(evidence.getEventLog(), actual);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetNonce() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce_args for GetNonce() API
            GetNonceArgs nonce_args = new GetNonceArgs("mock-request-id");
            assertNotNull(nonce_args);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Calling the GetNonce() API
            GetNonceResponse nonceResponse = connector.GetNonce(nonce_args);

            // Verify response is not empty
            assertNotNull(nonceResponse);
            assertNotNull(nonceResponse.getNonce());

            // Convert nonce values to Base64 decoded bytes
            byte[] decodedBytesVal = Base64.from(nonce_val).decode();
            byte[] decodedBytesIat = Base64.from(nonce_iat).decode();
            byte[] decodedBytesSignature = Base64.from(nonce_signature).decode();

            // Verify the response
            assertArrayEquals(decodedBytesVal, nonceResponse.getNonce().getVal());
            assertArrayEquals(decodedBytesIat, nonceResponse.getNonce().getIat());
            assertArrayEquals(decodedBytesSignature, nonceResponse.getNonce().getSignature());
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetNonceFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce_args for GetNonce() API
            GetNonceArgs nonce_args = new GetNonceArgs(null);
            assertNotNull(nonce_args);

            // Stubbing the response with an invalid nonce
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_nonce"));

            // Calling the GetNonce() API
            GetNonceResponse nonceResponse = connector.GetNonce(nonce_args);
            assertNull(nonceResponse);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetToken() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Create a mock GetTokenArgs object
            GetTokenArgs mockArgs = mock(GetTokenArgs.class);
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            Evidence mockEvidence = mock(Evidence.class);
            when(mockArgs.getNonce()).thenReturn(mockNonce);
            when(mockArgs.getEvidence()).thenReturn(mockEvidence);
            when(mockArgs.getPolicyIds()).thenReturn(Arrays.asList(UUID.randomUUID()));
            when(mockArgs.getRequestId()).thenReturn("mock-request-id");

            // Sample token to be sent from server
            String token = "mock-token";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"token\":\"" + token + "\"}"));

            // Calling the GetToken() API
            GetTokenResponse tokenResponse = connector.GetToken(mockArgs);
            assertNotNull(tokenResponse);

            // Verify the response
            assertEquals("mock-token", tokenResponse.getToken());

            // Test GetTokenResponse creation
            Map<String, List<String>> mockHeaders = mock(Map.class);
            GetTokenResponse testTokenResponse = new GetTokenResponse(token, mockHeaders);
            assertNotNull(testTokenResponse);
            assertEquals(testTokenResponse.getToken(), token);
            assertEquals(testTokenResponse.getHeaders(), mockHeaders);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetTokenFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Create a mock GetTokenArgs object
            GetTokenArgs mockArgs = mock(GetTokenArgs.class);
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            Evidence mockEvidence = mock(Evidence.class);
            when(mockArgs.getNonce()).thenReturn(mockNonce);
            when(mockArgs.getEvidence()).thenReturn(mockEvidence);
            when(mockArgs.getPolicyIds()).thenReturn(Arrays.asList(UUID.randomUUID()));
            when(mockArgs.getRequestId()).thenReturn(null);

            // Stubbing the response with an invalid token and
            // response code 503 to exercise doRequest() retry
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(503)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_token"));

            // Calling the GetToken() API
            GetTokenResponse tokenResponse = connector.GetToken(mockArgs);
            assertNull(tokenResponse);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testAttest() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Sample token to be sent from server
            String token = "mock-token";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"token\":\"" + token + "\"}"));

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Sample requestID
            String expectedRequestID = "mock-request-id";

            // Sample token-signing-algo
            String expectedTokenSigningAlg = "mock-token-signing-algo";

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, expectedRequestID, expectedTokenSigningAlg);

            AttestResponse response = connector.attest(attestArgs);

            // Verify the response
            assertNotNull(response);
            assertEquals(response.getToken(), "mock-token");
            assertNotNull(response.getHeaders());

            // Test setters/getters
            attestArgs.setRequestId(expectedRequestID);
            attestArgs.setPolicyIds(mockPolicyIDs);
            attestArgs.setAdapter(mockAdapter);
            attestArgs.setTokenSigningAlg(expectedTokenSigningAlg);
            assertEquals(attestArgs.getRequestId(), expectedRequestID);
            assertEquals(attestArgs.getPolicyIds(), mockPolicyIDs);
            assertEquals(attestArgs.getAdapter(), mockAdapter);
            assertEquals(attestArgs.getTokenSigningAlg(), expectedTokenSigningAlg);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testAttestNonceFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response with an invalid nonce
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_nonce"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, "mock-request-id", "mock-token-signing-algo");
            AttestResponse response = connector.attest(attestArgs);
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testAttestTokenFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Stubbing the response with an invalid token
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_token"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, "mock-request-id", "mock-token-signing-algo");
            AttestResponse response = connector.attest(attestArgs);
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetTokenSigningCertificates() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"keys\":[{\"kty\":\"RSA\",\"n\":\"u1SU1LfVLPHCozMxH2Mo4lgOEePzNm0tRgeLezV6ffAt0gunVTLw7onLRnrq0/IzW7yWR7QkrmBL7jTKEn5u+qKhbwKfBstIs+bMY2Zkp18gnTxKLxoS2tFczGkPLPgizskuemMghRniWaoLcyehkd3qqGElvW/VDL5AaWTg0nLVkjRo9z+40RQzuVaE8AkAFmxZzow3x+VJYKdjykkJ0iT9wCS0DRTXu269V264Vf/3jvredZiKRkgwlL9xNAwxXFg0x/XFw005UWVRIkdgcKWTjpBP2dPwVZ4WWC+9aGVd+Gyn1o0CLelf4rEjGoXbAAEgAqeGUxrcIlbjXfbcmw==\",\"e\":\"AQAB\",\"alg\":\"PS384\",\"x5c\":[\"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\"],\"kid\":\"12345\"}]}"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNotNull(response);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetTokenSigningCertificatesFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response and induce a failure response code 404
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(404)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("Not Found"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testOpenConnectionWithRetries() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response and induce a response code 503 to exercise retry mechanism
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(503)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("hello-world"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidToken() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid token
            JWTClaimsSet invalidClaims = connector.verifyToken(invalidToken);
            assertNull(invalidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenMissingKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with missing Kid token
            JWTClaimsSet missingKidClaims = connector.verifyToken(tokenMissingKid);
            assertNull(missingKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid Kid token
            JWTClaimsSet invalidKidClaims = connector.verifyToken(tokenInvalidKid);
            assertNull(invalidKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenWrongKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with wrong Kid token
            JWTClaimsSet wrongKidClaims = connector.verifyToken(tokenWrongKid);
            assertNull(wrongKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenMalformedJwks() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_jwks"));

            // Calling the verifyToken() API with valid token
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenJwksNoKeys() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{ \"keys\": [] }"));

            // Calling the verifyToken() API with valid token
            // and jwks with no keys
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidJwks() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(invalidJwks));

            // Calling the verifyToken() API with valid token
            // wrong jwks with verification failure
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidJwtAlgorithm() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid algo token
            JWTClaimsSet claims = connector.verifyToken(tokenInvalidAlg);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLEmptyURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Calling the getCRL() API with empty string
            X509CRL crl = connector.getCRL(null);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLInvalidURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = ":trustauthority.intel.com";

            // Calling the getCRL() API with invalid string
            X509CRL crl = connector.getCRL(crlUrl);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLValidURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = cfg.getBaseUrl() + "/ats-ca-crl.der";

            // Convert Crl from hex to bytes
            byte[] CrlBytes = hexStringToByteArray(crlHex);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/ats-ca-crl.der"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(CrlBytes));

            X509CRL crl = connector.getCRL(crlUrl);
            assertNotNull(crl);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetCRLInvalidCRL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = cfg.getBaseUrl() + "/ats-ca-crl.der";

            // Convert Crl from hex to bytes
            byte[] invalidCertBytes = hexStringToByteArray(invalidCertHex);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/ats-ca-crl.der"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(invalidCertBytes));

            X509CRL crl = connector.getCRL(crlUrl);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLEmptyCerts() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            X509Certificate leafCertificate = null;
            X509Certificate intermediateCertificate = null;

            // Calling the getCRL() API with empty string
            boolean verified = connector.verifyCRL(null, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLValidCertAndCrl() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(validInterCaCertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from crlHex
            byte[] CrlBytes = hexStringToByteArray(crlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(CrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertTrue(verified);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testVerifyCRLInvalidCACert() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(invalidCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(invalidCACertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from crlHex
            byte[] CrlBytes = hexStringToByteArray(crlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(CrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLOutdatedCrl() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(validInterCaCertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from outdatedCrlHex
            byte[] outdatedCrlBytes = hexStringToByteArray(outdatedCrlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(outdatedCrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLDistributionPoints() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Testing getCRLDistributionPoints() function
            List<String> listcrlDistributionPointsUriLeafCert = connector.getCRLDistributionPoints(leafCertificate);
            assertNotNull(listcrlDistributionPointsUriLeafCert);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetCRLDistributionPointsFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert string to X509Certificate
            X509Certificate certificate = (X509Certificate) CertificateFactory
                                            .getInstance("X.509")
                                            .generateCertificate(new ByteArrayInputStream(certNoDistributionPoints.getBytes()));

            // Testing getCRLDistributionPoints() function
            List<String> listcrlDistributionPointsUriLeafCert = connector.getCRLDistributionPoints(certificate);
            assertNull(listcrlDistributionPointsUriLeafCert);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChain() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(validJwks);

            // Parse the JWKS and retrieve the X.509 certificates
            List<X509Certificate> certificates = connector.extractCertificatesFromJWKS(jwkSet);

            // Verify the certificate chain
            if (!connector.verifyCertificateChain(certificates)) {
                throw new Exception("Certificate chain verification failed");
            }
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testVerifyCertificateChainWrongLeafCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(leafVerificationFailureJWKS);

            // Parse the JWKS and retrieve the X.509 certificates
            List<X509Certificate> certificates = connector.extractCertificatesFromJWKS(jwkSet);

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChainWrongInterCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(intermediateVerificationFailureJWKS);

            // Parse the JWKS and retrieve the X.509 certificates
            List<X509Certificate> certificates = connector.extractCertificatesFromJWKS(jwkSet);

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChainWrongRootCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(rootVerificationFailureJWKS);

            // Parse the JWKS and retrieve the X.509 certificates
            List<X509Certificate> certificates = connector.extractCertificatesFromJWKS(jwkSet);

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    /**
     * Helper function to convert hex string to byte[]
     *
     * @param hexString   hex string
     * @return            byte[] object of hex string
     */
    private byte[] hexStringToByteArray(String hexString) {
        int len = hexString.length();
        byte[] data = new byte[len / 2];

        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4)
                                 + Character.digit(hexString.charAt(i + 1), 16));
        }

        return data;
    }
}