/*
 *   Copyright (c) 2023-2024 Intel Corporation
 *   All rights reserved.
 *   SPDX-License-Identifier: BSD-3-Clause
 */
package com.intel.trustauthority.connector;

// JUnit imports for assertions and test annotations
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

// MockServer imports for HTTP server mocking
import org.mockserver.client.MockServerClient;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.HttpResponse;

// Base64 utility import
import com.nimbusds.jose.util.Base64;

// Mockito imports for mocking objects and defining behavior
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.mock;
import static org.mockito.ArgumentMatchers.any;

// Utility imports
import java.io.ByteArrayInputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.cert.X509CRL;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.UUID;

// Nimbus JOSE+JWT library import for JWT claims set
import com.nimbusds.jwt.JWTClaimsSet;
import com.intel.trustauthority.connector.Evidence.EvidenceType;
import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;

/**
 * TrustAuthorityConnectorTest contains unit tests for all APIs exposed by the TrustAuthorityConnector
 */
public class TrustAuthorityConnectorTest {

    // Initialize Mock Server object
    private ClientAndServer mockServer;

    // Initialize Config and TrustAuthorityConnector
    private Config cfg;
    private TrustAuthorityConnector connector;

    // Declare jwks samples
    String validJwks;
    String invalidJwks;
    String leafVerificationFailureJWKS;
    String intermediateVerificationFailureJWKS;
    String rootVerificationFailureJWKS;

    // Declare token samples
    String validToken;
    String invalidToken;
    String tokenWrongKid;
    String tokenInvalidKid;
    String tokenMissingKid;
    String tokenInvalidAlg;

    // Declare cert/crl samples
    String invalidCertHex;
    String invalidCACertHex;
    String crlHex;
    String validCertHex;
    String validInterCaCertHex;
    String outdatedCrlHex;
    String certNoDistributionPoints;
    String kid;

    @Before
    public void setup() {
        try {
            // Setup Mock Server
            mockServer = new ClientAndServer(); // No-args constructor will start on a free port

            // Default RetryConfig
            RetryConfig retryConfig = new RetryConfig(2, 2, 2);

            // Initialize config required for connector
            cfg = new Config("http://localhost:" + mockServer.getPort(),
                             "http://localhost:" + mockServer.getPort(),
                             "some_key", retryConfig);
            assertNotNull(cfg);

            // Initializing connector with the config
            connector = new TrustAuthorityConnector(cfg);
            assertNotNull(connector);

            // Verify connector config
            assertEquals(connector.getConfig(), cfg);
            
            // token samples for testing
            validToken = "eyJhbGciOiJQUzM4NCIsImprdSI6Imh0dHBzOi8vYW1iZXItdGVzdDEtdXNlcjEucHJvamVjdC1hbWJlci1zbWFzLmNvbS9jZXJ0cyIsImtpZCI6IjFhMWEyZmU1ZmNmODkwMDllNGI5NmM0NWUwZGNlYjAwNWVhNjM1ZDhiYTJmNmVkOWNhZWVmNDRhZTIzNTk3MGRlY2M1ODYxNTRmZDlmNzQwZmIzYjcyY2ExNzZhYmI1OSIsInR5cCI6IkpXVCJ9.eyJzZ3hfbXJlbmNsYXZlIjoiMGE3NTZhNjUzYjlhOTJiMTNkYmQ2MjRhNWE1OTY4MTU4OTViMTMwODIwYzU1ZjNiMWI3Y2FmYjMwNDY5NjViYyIsInNneF9tcnNpZ25lciI6ImQ0MTJhNGYwN2VmODM4OTJhNTkxNWZiMmFiNTg0YmUzMWUxODZlNWE0Zjk1YWI1ZjY5NTBmZDRlYjg2OTRkN2IiLCJzZ3hfaXN2cHJvZGlkIjowLCJzZ3hfaXN2c3ZuIjowLCJzZ3hfcmVwb3J0X2RhdGEiOiI0MDE4OWU5YmRiZmRjMzA5OWEwZmE3MzVlYTEyNjkwZDI3MTEyZGUyOWRkYjgxNDFkMGNhYzMzMGNjM2FiYjE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInNneF9pc19kZWJ1Z2dhYmxlIjpmYWxzZSwic2d4X2NvbGxhdGVyYWwiOnsicWVpZGNlcnRoYXNoIjoiYjJjYTcxYjhlODQ5ZDVlNzk5NDUxYjRiZmU0MzE1OWEwZWU1NDgwMzJjZWNiMmMwZTQ3OWJmNmVlM2YzOWZkMSIsInFlaWRjcmxoYXNoIjoiZjQ1NGRjMWI5YmQ0Y2UzNmMwNDI0MWUyYzhjMzdhMmFlMjZiMDc3ZjJjNjZiOTE5ODQzMzY1MzE4YTU5MzMyYyIsInFlaWRoYXNoIjoiOTk1ZDljMmUyYmVhNzYyOWEzMmI2NWUxMmZmZjc1MzJkM2M2YTc2YWFmODEwYjgwZTg5Y2RjNjE4YTJmYTVjOSIsInF1b3RlaGFzaCI6IjViMzJhMWUyZmJjOTdlNTJjZWMxNDgxZTg5ZTNmMmFmYmFjM2QzMDZmMDE5ZTBiYTA3OTAwNGM0ZWM0MzRlNTMiLCJ0Y2JpbmZvY2VydGhhc2giOiJiMmNhNzFiOGU4NDlkNWU3OTk0NTFiNGJmZTQzMTU5YTBlZTU0ODAzMmNlY2IyYzBlNDc5YmY2ZWUzZjM5ZmQxIiwidGNiaW5mb2NybGhhc2giOiJmNDU0ZGMxYjliZDRjZTM2YzA0MjQxZTJjOGMzN2EyYWUyNmIwNzdmMmM2NmI5MTk4NDMzNjUzMThhNTkzMzJjIiwidGNiaW5mb2hhc2giOiI3M2UwYzhkNDU2ODdhMTU2YzUyNzQ1YmRlOWJkMDRkZGU2MTcxY2YzMjFmNDA3NDE5Zjg0MGU5YmJhYzY1ZTAxIn0sImF0dGVzdGVyX2hlbGRfZGF0YSI6IkFRQUJBQjBuQ1RNR3dXOXdtYy93M3dKSGwraDRnODJwMGQ4aWpGU3ZuT2JBdTBEb3pWdHR2d3NweEJRK1ZCdXMvNDhJQVBLQnhmV3owcjYybWNjeHJWMTRndFJaWU9RWHBXUnNPeUF3cHJoNndqWHlHdmtrbDNuVEQ0a0Y0L29WZ1NVaUlwZDZMcjFxUVd6a2N0bnhoWHpkWkxpVWp3TktPNHdIaFdoV1hVNEduSEl4SmQwVUtiQXIyM2lPNGRrSnkxY3dmNUZxd0pROVI2L3UrYW1vLzI0QkZDQUNLamZhbHNpaThXendtSE5UQ3hNeWtGOE0zWEwrTjJCSFdsVlNOa21VLzFSMlp2eFk2V3pQRUpsbGkwVHhySWJwaG1SdHpKM3E2cDdPSktPT2dXKzFCdkxtcUd4K05ZL2xqNjQvRXJOKzBZTVZLNGI3ZU05ZTFIVS9qQ0JRVlpvTnM1LzB1ZUgyOGpjZTJBSituWWUyUFc0R2hXallueklaYnZNTy9QKy9RR3NvRXJlZ2RsQ0c3ZWVvMUZxV1dtdUt0S3N3RStwRmFXbmQwMFJOZ29qMU81anJERmJMM0RpTVYwTGNVOTU5Q3BjV2lkN1VKYmlEUTM1OUgrVVhXZmpNdVJ3aE0yanJhaE9nczd2dFdtWUcrcnZEb0dTS29DQVBQNVhlNlRoU3lBPT0iLCJ2ZXJpZmllcl9ub25jZSI6eyJ2YWwiOiJWV2N3V1hCbmIwdGtiSEJ6YXpaVlZITTBPVGRGWVdoM01Wb3JkVmhHU0VaSlFXVXdTMXBpTXpOVlREa3dlVkl2WTJnemVsRkZkRGx5UVdZM1dYZHhia1ptWWtRMU9WZE5MMnB6VW5GeE1HVnBSRTlZVUVFOVBRPT0iLCJpYXQiOiJNakF5TXkweE1pMHlNU0F3TlRvek1Ub3dPQ0FyTURBd01DQlZWRU09Iiwic2lnbmF0dXJlIjoiVXAyZlluNUhwcTVpbXRmeXZmaWZEQisrbjV2bVVhcXZydU9kQVVtckg4OG5JRWorQU94NXk1ck5sV1BqWkNWcnk1emxpcjVOdUVNa0ZJc2FQV1pJM0t1L2ozQlZNM081dk0yOGJFR3lSYTA2V2phQWtLbktLZ3hrK3NaMG54RVluUGxuTGtweW81YjVKbXBEOFJOWm5iL2d2OXBYaWVxZU1OYThnTStkK2pwMk90M0VqUzR1VmhUYllSYmdxamJ6VlBhNEYrTVgrbnUzR01FSmdKdFlvZnFtZnRHa25mc1VHdW1BVE12Z21NdVV4Vk1lSFhQUUFGd1I4RWJrTE1odzlxOUVyVU1YdTB1Z045cTdsd2QrNUJKZ1pGR0lyeWNWZTRudzJGTVZITzI5SHdlMzM0czdQZ002SEpQR3NpaDN2S3dNVXM4SSt0MWVnUDRzcjJERWJPblZlS254VFdwV1IraUNqZks0NmJicE80VS9GYmN4c0k2SXAxK3ZvOVd5WDBCQVpFSmpuWHpMZGYydHZVRnJjcmJ1dFVYWW1xaWd5dks5SmtpcWltR29JQ3ptYjZuc25wSmJOeFlDK3RNY1FtUFk0ekgva2x2K3p3N0FVZnZvUXFpRG13UmtDYUgvcTRNdmNsKzBwUkwrUFUrbkdidkpHZHJHNk9LVSt2T2UifSwicG9saWN5X2lkc19tYXRjaGVkIjpbeyJpZCI6IjkxNDg4ZTEyLWYzOWUtNGYzZS04NDM1LWQ0OWM4MTNkZWNiNSIsInZlcnNpb24iOiJ2MSJ9XSwicG9saWN5X2lkc191bm1hdGNoZWQiOlt7ImlkIjoiN2YzODE0MzAtNTFmOC00N2IwLWE2ZTAtMzkzZWYxODM3YWYzIiwidmVyc2lvbiI6InYxIn1dLCJwb2xpY3lfZGVmaW5lZF9jbGFpbXMiOnt9LCJhdHRlc3Rlcl90Y2Jfc3RhdHVzIjoiT3V0T2ZEYXRlIiwiYXR0ZXN0ZXJfdGNiX2RhdGUiOiIyMDIxLTExLTEwVDAwOjAwOjAwWiIsImF0dGVzdGVyX2Fkdmlzb3J5X2lkcyI6WyJJTlRFTC1TQS0wMDU4NiIsIklOVEVMLVNBLTAwNjE0IiwiSU5URUwtU0EtMDA2MTUiLCJJTlRFTC1TQS0wMDY1NyIsIklOVEVMLVNBLTAwNzMwIiwiSU5URUwtU0EtMDA3MzgiLCJJTlRFTC1TQS0wMDc2NyIsIklOVEVMLVNBLTAwODI4IiwiSU5URUwtU0EtMDA4MzciXSwiYXR0ZXN0ZXJfdHlwZSI6IlNHWCIsInZlcmlmaWVyX2luc3RhbmNlX2lkcyI6WyI5YTRlMjQ2OS03NGIwLTQ4OWQtOTczYi1jMTU0NzllODNhZDEiLCIxNDc2ZGE3NC0yOTdkLTRiYzEtYjdkMi0xMGUyNTk1MGJhN2MiLCJjMTQyMTcyNi1lYjViLTRmYWEtYmEzOC0zNWZiMGM3ZDk1NDYiLCI4NGNmZGUzYi0wM2Q1LTQ4ZWYtYTIxMC0xZWY5ZTU2MTE2YTMiXSwiZGJnc3RhdCI6ImRpc2FibGVkIiwiZWF0X3Byb2ZpbGUiOiJodHRwczovL2FtYmVyLXRlc3QxLXVzZXIxLnByb2plY3QtYW1iZXItc21hcy5jb20vZWF0X3Byb2ZpbGUuaHRtbCIsImludHVzZSI6ImdlbmVyaWMiLCJ2ZXIiOiIxLjAuMCIsImV4cCI6MTcwMzEzNjk2OCwianRpIjoiOGViNDg2NmMtNTc0Ni00YzdkLWJlNzktM2UwNDlkYzBhNzQ5IiwiaWF0IjoxNzAzMTM2NjY4LCJpc3MiOiJJbnRlbCBUcnVzdCBBdXRob3JpdHkiLCJuYmYiOjE3MDMxMzY2Njh9.tf9oqTHuJKA8LPcqqHndNgLlc7GxCkNx3TerIbHU9OpzoU6pEnbcDo8655p3X1LUQQ1yb-fi5IqRZYO8-KCnsCCAuID8ff4bGwBKCExN0xP656tLbh3w7dyh7miIuJz9JBVvDn41CPKcRotuzoMjMIQzQQiIBaU4bRBDEWHaMEHoGM8qr0KXqz0YP3kKT1f4fL7FAKHjSyxNqqw3_bxFaeFvEBcTCnRBgEUAIxd79Yq0LndDenxAkfEaXOmtCSd_t9-vs7zzBKvbZ_wurVnXQbLaLM8DEMzykZmTB5yIERbrfFzkR-61Uv3cibWGdR8Be0shc3pgvgcXtSKaPsLdNI7pf17S0fCEMwCKtIBStHcDVbyz8fvDHnW8lUsHXHWY4hrXJfTfH0DnoISJCXpXoLLr43D8wAd4PLdUOzaQ0tMYRtCnsWW5lzvpReHzD13GjgCb_2T1KutxR6a9QidIbAAi8i1EUwmvjlloQyPwV0neC5Gczetd79zHHNRrDjpW";
            tokenWrongKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.O1YS3tK9moRRMCLkqWloLHIJ_F-NfpfQVFLo4mq3ui4HCgQLAK7bELjHl__igbzF6zTOLd3fwaoCKeVF1DDwBBoPhMXkAjZQMaNBFz8xZghQZfkSJLiMygyrkzSqgzLFMOgdBJaqcKxWT-cbO3JyAmG4sbxxFo8Lh5foVCmzF88aqfX0MPvUuiQG9aNVvJFqj2gW9hTSB3ljhxeRqZhTSQcpEkE67Xpr70rcdXaLbK-Ab4gw9YrW4aMHqR1aeLWg-s1OTosRpJGKLQ90BqWUJSx1QCmzRbAsEOfUeIK2CSwD0miUw6aSR2tVQcj0peZ2T-1xr8j0UFHRGCo5iLyAGBrHuNZ5c3fPL_xygwAkGKSkaO22d0NLRjauNeMKwT16BqZvZdN050AhfkMrwPa6AxQeJC__uBiIScKWK5ZSJJP3ba0_LHCsnnAOVZJMdD0uGdvzwXLhCTT44yeGVRbmw6KvLKjwLLotEsXY6M84rtMYnP16XeenidMH0-5YoaNOkFMR987qV-q2yXRemEHdH4KzmoBnMPtlvTSi1XW4jTM7bgziPEEK44mfZC_bkHKQnEWT51whYOPgcWYwYfjBm0oMoPKeCuIbHU6tMceGqZTsAzaWUSSlti_jVmQFR6Pp22w1d7BY-TGKDDG_wK4adj4n_KoGw5_HFYwoQfb6G_o";
            tokenInvalidKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6MTIzNH0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.lsBarFSfZNLtmTJyKfcnxqoU80QTx2PJHU0cl4esXIi64iD0C0h_B2TobIfkcUHIDNnkwcmZmik9dMxQaKU59qW6yUPgN9GcglD6RpgrJ4StHaOpfJvWY6TtsuSdcWlG33wc9RhcZ4PXV4pdYx5210e0PRgGAPelyq0MvdZa1IpZUnssQulMrk6OJNs3L-7ZfI5ZQFmJyWMzWcY7HQ9Nk2vfjaYtChfmKCSVdbyrDjtzsSDY9r5bYMI5pUCxXl30RSiEYv8fOBpYB_TJPxHyC0VaYtYVLIl4ZzUzG5VS4ragjJVXZZkX1tcDSpTakmgMbcvT1aqyJ9iVGJKSzfPovht-HxYlnmPysQPgeYY4LMywlRW8RJned9ZmKZ4F5Y8aTAUWdO4_ruBL0u8Z7J8-BTGkvNUgBUx9c7p_uy1dt7MTQkDW7d6sjP89xoNHnz4z4w7erAEuBEaPrknmYokpIdqf-esynBtW4NfIKyfl-_PGJnngPn7ziBNuTqxzq0sgTdovX8nxwal3LeWVtXx6HzN5CIRcR7BpDNC5jRhsyZ0U-p4D9Iic63KXMQLhkMx3D0vxzpzlT_zhkvw-kqXNsp6sIN3XqwlZjNTX6lptjV_OXnpVgJ8pb5svURGbwWcFIDJlgaYkHn7jLHnnaKz1aaHQezClod6_vbEPyjcfrsI";
            tokenMissingKid = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.IO_z9EOfF9e2noXDva33D8D2y9CS8Tf9lmB-w7cK5DNawk0r66RrjmY-jk6p8MIha126nniMRI7UZaeSSrfzwwuYVZCD35X7xRqhsRz5mpVkoluooXENIVvE4F8UVpY4yewgB6JXvFFplqaXWCSoQ8GxmwHXnHwEzS_W0df5VqTTBilRtgEEbwqBnANWWVkzm89ZX9d2ebkgow5dG9O-ra0SNhO_-66a4b78wvhiE_dw-99pnYbU-XLUwqVEu1Nk4sMW9jp7Y7d0f_WR9uOcB4SvojVJBTGc9cuCBjDI8g2zYyFs04exifYF7SQiofn1KodR5FDwOUiNwQfC-isnwa9fpKPOuGXEOJm6FBCK7cYrpP0JQrOv3IVeIh1Qix3N6-sF_TfUWgzBZlolvaf98msky8Yv0udyL0rkKMUUStV48R4TTChuAtpxoSu1Fr-sdMhWf76xGHvXjTUL_W4TZA8a3GyxLHawbcXez-Sk357djVol5xDIVAZU3ORpT4RuwPBKaoodEBSSWnFlP0l577Y7J8St0_UdGCyg8TMt2MBjaah1EJRDLOiXw_C0_Efa0rid6HbKlzwhlk6BzXQbnxdRoFBnh2KcsewQMMKfVtv3_nFxvgyiMTgdXY1lbmmVJ9rmEJlVyzCdfLoZavSrBwl5xkGipr657fmZ2Tbe6j0";
            invalidToken = "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6IjNmZDc1MWYyZTBkMGY1Mjg0NmMwZWNkNDk3MmM2ZTk5ZGZjNjQyMDUxY2QzMzlkZDliMDQzODFhZjhjMGRkYjgwNDUxNGE3YTFmZWU0NjczYWM4NDRmZDVkYjdmMTVmYiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.tJPT6hz2psdkB2yuf17UjqcH1t4ujt9iwRP8iFrG93vMZN2W8umIlYVCE9NVigYoX3EkNuOq_OGlYvfdrUjsYFU-hFLvmORLbaBZ2u0GCfxgrGpYX7ngjZRad_cE9KGcmv6R2fxWI4gF-73DMeaoGWXTVAPlquV_Tyc987zeXj1KXAVO0SDWG68LiWVcl42FUlOI_2mXV4rGsgWLPgbyaa5SuSu-ENreQenvyUMMzdntbJtytQycOxYVrppQJaFNKwn8OfwloGvt7jedylCZgU1MBIrTXUN_lgKAZnFfRxUMfbiV-i73kPqWcOAxbzK8JZPAKv4AyVDWFEBhKKuxiQ";
            tokenInvalidAlg = "eyJhbGciOiJIUzM4NCIsImprdSI6Imh0dHBzOi8vYW1iZXItdGVzdDEtdXNlcjEucHJvamVjdC1hbWJlci1zbWFzLmNvbS9jZXJ0cyIsImtpZCI6IjFhMWEyZmU1ZmNmODkwMDllNGI5NmM0NWUwZGNlYjAwNWVhNjM1ZDhiYTJmNmVkOWNhZWVmNDRhZTIzNTk3MGRlY2M1ODYxNTRmZDlmNzQwZmIzYjcyY2ExNzZhYmI1OSIsInR5cCI6IkpXVCJ9.eyJzZ3hfbXJlbmNsYXZlIjoiMGE3NTZhNjUzYjlhOTJiMTNkYmQ2MjRhNWE1OTY4MTU4OTViMTMwODIwYzU1ZjNiMWI3Y2FmYjMwNDY5NjViYyIsInNneF9tcnNpZ25lciI6ImQ0MTJhNGYwN2VmODM4OTJhNTkxNWZiMmFiNTg0YmUzMWUxODZlNWE0Zjk1YWI1ZjY5NTBmZDRlYjg2OTRkN2IiLCJzZ3hfaXN2cHJvZGlkIjowLCJzZ3hfaXN2c3ZuIjowLCJzZ3hfcmVwb3J0X2RhdGEiOiI0MDE4OWU5YmRiZmRjMzA5OWEwZmE3MzVlYTEyNjkwZDI3MTEyZGUyOWRkYjgxNDFkMGNhYzMzMGNjM2FiYjE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInNneF9pc19kZWJ1Z2dhYmxlIjpmYWxzZSwic2d4X2NvbGxhdGVyYWwiOnsicWVpZGNlcnRoYXNoIjoiYjJjYTcxYjhlODQ5ZDVlNzk5NDUxYjRiZmU0MzE1OWEwZWU1NDgwMzJjZWNiMmMwZTQ3OWJmNmVlM2YzOWZkMSIsInFlaWRjcmxoYXNoIjoiZjQ1NGRjMWI5YmQ0Y2UzNmMwNDI0MWUyYzhjMzdhMmFlMjZiMDc3ZjJjNjZiOTE5ODQzMzY1MzE4YTU5MzMyYyIsInFlaWRoYXNoIjoiOTk1ZDljMmUyYmVhNzYyOWEzMmI2NWUxMmZmZjc1MzJkM2M2YTc2YWFmODEwYjgwZTg5Y2RjNjE4YTJmYTVjOSIsInF1b3RlaGFzaCI6IjViMzJhMWUyZmJjOTdlNTJjZWMxNDgxZTg5ZTNmMmFmYmFjM2QzMDZmMDE5ZTBiYTA3OTAwNGM0ZWM0MzRlNTMiLCJ0Y2JpbmZvY2VydGhhc2giOiJiMmNhNzFiOGU4NDlkNWU3OTk0NTFiNGJmZTQzMTU5YTBlZTU0ODAzMmNlY2IyYzBlNDc5YmY2ZWUzZjM5ZmQxIiwidGNiaW5mb2NybGhhc2giOiJmNDU0ZGMxYjliZDRjZTM2YzA0MjQxZTJjOGMzN2EyYWUyNmIwNzdmMmM2NmI5MTk4NDMzNjUzMThhNTkzMzJjIiwidGNiaW5mb2hhc2giOiI3M2UwYzhkNDU2ODdhMTU2YzUyNzQ1YmRlOWJkMDRkZGU2MTcxY2YzMjFmNDA3NDE5Zjg0MGU5YmJhYzY1ZTAxIn0sImF0dGVzdGVyX2hlbGRfZGF0YSI6IkFRQUJBQjBuQ1RNR3dXOXdtYy93M3dKSGwraDRnODJwMGQ4aWpGU3ZuT2JBdTBEb3pWdHR2d3NweEJRK1ZCdXMvNDhJQVBLQnhmV3owcjYybWNjeHJWMTRndFJaWU9RWHBXUnNPeUF3cHJoNndqWHlHdmtrbDNuVEQ0a0Y0L29WZ1NVaUlwZDZMcjFxUVd6a2N0bnhoWHpkWkxpVWp3TktPNHdIaFdoV1hVNEduSEl4SmQwVUtiQXIyM2lPNGRrSnkxY3dmNUZxd0pROVI2L3UrYW1vLzI0QkZDQUNLamZhbHNpaThXendtSE5UQ3hNeWtGOE0zWEwrTjJCSFdsVlNOa21VLzFSMlp2eFk2V3pQRUpsbGkwVHhySWJwaG1SdHpKM3E2cDdPSktPT2dXKzFCdkxtcUd4K05ZL2xqNjQvRXJOKzBZTVZLNGI3ZU05ZTFIVS9qQ0JRVlpvTnM1LzB1ZUgyOGpjZTJBSituWWUyUFc0R2hXallueklaYnZNTy9QKy9RR3NvRXJlZ2RsQ0c3ZWVvMUZxV1dtdUt0S3N3RStwRmFXbmQwMFJOZ29qMU81anJERmJMM0RpTVYwTGNVOTU5Q3BjV2lkN1VKYmlEUTM1OUgrVVhXZmpNdVJ3aE0yanJhaE9nczd2dFdtWUcrcnZEb0dTS29DQVBQNVhlNlRoU3lBPT0iLCJ2ZXJpZmllcl9ub25jZSI6eyJ2YWwiOiJWV2N3V1hCbmIwdGtiSEJ6YXpaVlZITTBPVGRGWVdoM01Wb3JkVmhHU0VaSlFXVXdTMXBpTXpOVlREa3dlVkl2WTJnemVsRkZkRGx5UVdZM1dYZHhia1ptWWtRMU9WZE5MMnB6VW5GeE1HVnBSRTlZVUVFOVBRPT0iLCJpYXQiOiJNakF5TXkweE1pMHlNU0F3TlRvek1Ub3dPQ0FyTURBd01DQlZWRU09Iiwic2lnbmF0dXJlIjoiVXAyZlluNUhwcTVpbXRmeXZmaWZEQisrbjV2bVVhcXZydU9kQVVtckg4OG5JRWorQU94NXk1ck5sV1BqWkNWcnk1emxpcjVOdUVNa0ZJc2FQV1pJM0t1L2ozQlZNM081dk0yOGJFR3lSYTA2V2phQWtLbktLZ3hrK3NaMG54RVluUGxuTGtweW81YjVKbXBEOFJOWm5iL2d2OXBYaWVxZU1OYThnTStkK2pwMk90M0VqUzR1VmhUYllSYmdxamJ6VlBhNEYrTVgrbnUzR01FSmdKdFlvZnFtZnRHa25mc1VHdW1BVE12Z21NdVV4Vk1lSFhQUUFGd1I4RWJrTE1odzlxOUVyVU1YdTB1Z045cTdsd2QrNUJKZ1pGR0lyeWNWZTRudzJGTVZITzI5SHdlMzM0czdQZ002SEpQR3NpaDN2S3dNVXM4SSt0MWVnUDRzcjJERWJPblZlS254VFdwV1IraUNqZks0NmJicE80VS9GYmN4c0k2SXAxK3ZvOVd5WDBCQVpFSmpuWHpMZGYydHZVRnJjcmJ1dFVYWW1xaWd5dks5SmtpcWltR29JQ3ptYjZuc25wSmJOeFlDK3RNY1FtUFk0ekgva2x2K3p3N0FVZnZvUXFpRG13UmtDYUgvcTRNdmNsKzBwUkwrUFUrbkdidkpHZHJHNk9LVSt2T2UifSwicG9saWN5X2lkc19tYXRjaGVkIjpbeyJpZCI6IjkxNDg4ZTEyLWYzOWUtNGYzZS04NDM1LWQ0OWM4MTNkZWNiNSIsInZlcnNpb24iOiJ2MSJ9XSwicG9saWN5X2lkc191bm1hdGNoZWQiOlt7ImlkIjoiN2YzODE0MzAtNTFmOC00N2IwLWE2ZTAtMzkzZWYxODM3YWYzIiwidmVyc2lvbiI6InYxIn1dLCJwb2xpY3lfZGVmaW5lZF9jbGFpbXMiOnt9LCJhdHRlc3Rlcl90Y2Jfc3RhdHVzIjoiT3V0T2ZEYXRlIiwiYXR0ZXN0ZXJfdGNiX2RhdGUiOiIyMDIxLTExLTEwVDAwOjAwOjAwWiIsImF0dGVzdGVyX2Fkdmlzb3J5X2lkcyI6WyJJTlRFTC1TQS0wMDU4NiIsIklOVEVMLVNBLTAwNjE0IiwiSU5URUwtU0EtMDA2MTUiLCJJTlRFTC1TQS0wMDY1NyIsIklOVEVMLVNBLTAwNzMwIiwiSU5URUwtU0EtMDA3MzgiLCJJTlRFTC1TQS0wMDc2NyIsIklOVEVMLVNBLTAwODI4IiwiSU5URUwtU0EtMDA4MzciXSwiYXR0ZXN0ZXJfdHlwZSI6IlNHWCIsInZlcmlmaWVyX2luc3RhbmNlX2lkcyI6WyI5YTRlMjQ2OS03NGIwLTQ4OWQtOTczYi1jMTU0NzllODNhZDEiLCIxNDc2ZGE3NC0yOTdkLTRiYzEtYjdkMi0xMGUyNTk1MGJhN2MiLCJjMTQyMTcyNi1lYjViLTRmYWEtYmEzOC0zNWZiMGM3ZDk1NDYiLCI4NGNmZGUzYi0wM2Q1LTQ4ZWYtYTIxMC0xZWY5ZTU2MTE2YTMiXSwiZGJnc3RhdCI6ImRpc2FibGVkIiwiZWF0X3Byb2ZpbGUiOiJodHRwczovL2FtYmVyLXRlc3QxLXVzZXIxLnByb2plY3QtYW1iZXItc21hcy5jb20vZWF0X3Byb2ZpbGUuaHRtbCIsImludHVzZSI6ImdlbmVyaWMiLCJ2ZXIiOiIxLjAuMCIsImV4cCI6MTcwMzEzNjk2OCwianRpIjoiOGViNDg2NmMtNTc0Ni00YzdkLWJlNzktM2UwNDlkYzBhNzQ5IiwiaWF0IjoxNzAzMTM2NjY4LCJpc3MiOiJJbnRlbCBUcnVzdCBBdXRob3JpdHkiLCJuYmYiOjE3MDMxMzY2Njh9.uDFxPnguPV1RGkF_486k9n0MDSti7rduYMbQKwH88SAdhBiiOp13NYx1qiOGa0-1";

            // crl/cert samples for testing
            invalidCertHex = "30820557308203bfa003020102020102300d06092a864886f70d01010d0500305b310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3123302106035504030c1a496e74656c20416d62657220415453205369676e696e67204341301e170d3233303431303137343732355a170d3233313030373137343732355a3060310b3009060355040613025553310b300906035504080c024341311a3018060355040a0c11496e74656c20436f72706f726174696f6e3128302606035504030c1f416d626572204174746573746174696f6e20546f6b656e205369676e696e6730820222300d06092a864886f70d01010105000382020f003082020a0282020100b833bb7f44d9a1521bf304c78b4080e3688d82c9fb5a8e9c513f314e7eeb4b87e92dfd04f029e96206a4a249e777c266fd69868dbc62d824261fa1c5656f811ea67b035155e806a75b858de937b65d0b9f2312d1bab91eb84697e064bee5fe63f5717c8aca3d50e075f1a8e8284f7cfee324a18060c9189bc1f92daf72cc8475151c1244e39513d8339aeb2cdcb39665065138356bdfc1c008e8ed382894fc662300b2caffcd52c06e739d7f5533414a7578b664156953d6b260dea206c8b59a02f60968d813bf75a8a0d8fb73f16d08bfcc88ec708da44ac7b6a227c81ff5e053439345f4a4e99fb0f2846630aab22123143486a705855113e81ba1aef52c31875a492f4dc1114be9254b2c86f2827c938add6ff35b5e112e7149132964abb2e4aabbf438cac65947ff38c171338be9323ecb1b101d0c2d6f38d6cb774de752c20f19569deb6f040943eb855225ca143de4265c8d199dec1f7f6d06b4dd6382ce22101f139533175972254bd782ad1f83e2ed3294611c6a9307cbe4d79e0db1b71e3bcee64f8af3ee5d0da52eb3ff9de4e0bc76e79c2cd5e58c5699bd8d755dad9ebe6f40a1c64e806c52ed7ee9bfe1e87f993d7d37cc7ef37d56aed50ba41dcecd52f35e83fa6b34d0ed6bc438c9a2e520f674977577856552b5f53ed9ba3083a92f81533d61d7321a3b355b8869c93a777661b635abf72395fb8f736ab7130203010001a381a030819d300c0603551d130101ff04023000301d0603551d0e04160414e4ddc5bd96e128a82465cb26e1bce1990d587898301f0603551d230418301680143bd92d080eb2c16881832d0d7436dc926e59c743300b0603551d0f0404030204f030400603551d1f043930373035a033a031862f5552493a68747470733a2f2f616d6265722e696e74656c662e636f6d2f6174732d7369676e696e672d63612e70656d300d06092a864886f70d01010d050003820181004279fb07bc3f336be663c838761dddb8ce5f7d28ae38800a707c4eb11c39434cb96fd741070ed1cb7becca26ab075deeb23667cfd533918fd3ccae394de3cc1ee07c800a0cb2ac7355beeb825a9a7fd791e63e8a058f260a7bf4bed9a1001154b3b9935fcc92f473aa86f933bc91e31677c4b5e08224e67e0b473ef8e82252a8430d6feec4cfd40ba0a64788346d29e1464f7e9cd497dcd35e6b561f8993d664f9d1cb08db555bd5510297cb766b7db0f032ab6ee57a495e485f87fc78fb5312948856b3c0c62b8056dc1308b40faf5bcc2fafdc871e464fb05398f4d47d35a9b39c0fdcb74ccea38bc41a821037a8e30190e998865fa8f0ae714aa4145e981a1601909eba2a9f5cd9584c7a4ae160396a692aa33d8fd686fe951e41d8ab14d01534c12477a5fae4ac715f4ee75da1e38f1689dfee2f4596da9ec069f000e80bb750a6aa2993bd049c1423ce1b677f5a7b6d28a962227507761acc156413d88baaf3bb3cb3c570aedbb11a7cb12f8329739abc44541d9d2811f0407816324433";
            invalidCACertHex = "308204c53082032da003020102021436441d9104098f2aa434e0c9d36db2ce0cf80828300d06092a864886f70d01010d0500306a311c301a06035504030c13496e74656c20416d62657220526f6f74204341310b3009060355040613025553310b300906035504080c0243413114301206035504070c0b53616e746120436c617261311a3018060355040a0c11496e74656c20436f72706f726174696f6e301e170d3233303431303137343732315a170d3439313233303137343732315a306a311c301a06035504030c13496e74656c20416d62657220526f6f74204341310b3009060355040613025553310b300906035504080c0243413114301206035504070c0b53616e746120436c617261311a3018060355040a0c11496e74656c20436f72706f726174696f6e308201a2300d06092a864886f70d01010105000382018f003082018a0282018100caaef4384fe8e11855f33557e7d6a9bbba6e578eaba2f6f883e1582ba44b3da4a0980512a29e59b8c07a554488a11183aa94ee84a3540f4d9995431189c476e8e62ca83914c243916384a31a59c0a8b647931cfb7455927164d51071942754e286e9792b176396a18138d44b944fc73263a1d0064b723298802c81bf7a5fd1a4a773a328c687b3c050e7395929879ad5fd8b31e64e581b6015e38ab6aa511b3ac4b703e6a2d622fd4d21748694081294038cec2b0a2122addb78e8247e67ff4ce4c1ac93c1db2f24d2ac857cef6d431817d01360eec2249fb00e29a7195f72ab8b9ada0a8d09b571c666ab70c93a265a54e5fbba330cd53abf62091f42a7fe55da41c7ba0735865941fb65a4e2c714b3c6b1bb3822947e6263fbfd4c1f6e9d15d7d4b94cf6dcd0868a966a823c2dd41aee7c7c74c1fa3f12c7ead3032559f751065fa13664adf4db057f4810f52b41009c79e57535cbc268300e2addbd342efce224f2d87a47db89ba31fee519b873044e40abacfb3cb503cc75ac63b5e732550203010001a3633061300f0603551d130101ff040530030101ff301d0603551d0e04160414de4aa628f84dc5e960d5a850207fa684acfe7a56301f0603551d23041830168014de4aa628f84dc5e960d5a850207fa684acfe7a56300e0603551d0f0101ff040403020106300d06092a864886f70d01010d05000382018100774792455f8ff0e45605d3b4edbf744563a3cebaf93a29116d5b585b5e74134ade6524be5652d72e4cc57e535f9639747f9dd15f252d3423cf1f0dfa0516c8c219e6d7ee9a9859977cfc5f81e887da7f1e12f52a43bb093c01350e4c25dea4795a208bc883960d5c29cc5a016864c6e0ccb275257b43e3e0b549dd5c6181a50802413676d1887ba2b1df8dcf3d7918d46187fdf0b5a4c52b2613af55c3bf57af8c619e73801084a9ffaa302ecf0fd31fa423025b3fa9cf88debcaf798eb3ecf188dd7d3362d476de168e533689ec32e67d4dc94a10d1eb2492b020fa72fa1c700baad9be5917f81ae9e8775c1b8c9f19127048b93d5bfbf201ad19ce462e1f85bf81d7e79fe5521071e9abe6b11dea7540a2bc89791b0f09354068b5466d2bd2f0a23aad44b54e1114ad8ae61b9615f76bd120d431e0494bcbd6750f5d6444b79e6bd0163c4a83dd312ebd55cdd63d1aacd808ab5155012d22ea15ec40dcbc6a69643d2ffe4fd970abe003e9f54e26a7234c8df9a972a7104b14675b8e8e3129";
            crlHex = "3082024f3081b8020101300d06092a864886f70d01010b05003073310b3009060355040613024455310f300d06035504080c0644756d6d7931310f300d06035504070c0644756d6d7931310f300d060355040a0c0644756d6d7931310f300d060355040b0c0644756d6d79313120301e06035504030c1744756d6d7920496e7465726d6564696174652043657274170d3234303331383035333434385a180f32313234303232333035333434385aa00f300d300b0603551d14040402021003300d06092a864886f70d01010b0500038201810052073822eed595e942f5727428487f04bfcd965fc0a8155037f87528e0e0ebb656b98cd085d8205446d3d1f1e781312f29a810e86dd2577c4980c511c67cdc410e5f5b03dda56123e58c805132b11817793e4fa4684ddcdf0bfcd9c69b52adb35edae12fd1c626d82ad5a08ec8d7710869e36fc707907a3c553c755d1b913d5e2ed1f9f60f78a5ae1e623aab9f45a79f2fd32f5b431b73491bf8e53d9733ebdccc8ff987d9da0277ccae74d2fc723c33bae041452f2f4c9a2a3f8f20eb04c2cf904b3403b4891012b2a1d5639b2aae24fff48b0301b11958e8da2003e9b977d94022b404044599eccbdd5ad66dc862711123e3a7b7b994d984beb7fac1bad1079c00e1e2dcb3d33679c8c96e281c21b2005ea69df2472c49a63d77b8995ef8a16b4e217f36c999c9162377b2e63ea4f6aa2f0966fc70dcb255177dee3c3687e2dd6be4e06ba948c751c03ac5c7c17eb43c6b082e14f068c4c926ddf9766e4552fd46e22d61a16bed4b66314ee30e76d61284ac5d4856b10cf43d2a7ffe37ac61";
            validCertHex = "308204dd30820345a00302010202142652fca04d604019c0d6de3b13f5f749b31cb104300d06092a864886f70d01010b05003073310b3009060355040613024455310f300d06035504080c0644756d6d7931310f300d06035504070c0644756d6d7931310f300d060355040a0c0644756d6d7931310f300d060355040b0c0644756d6d79313120301e06035504030c1744756d6d7920496e7465726d65646961746520436572743020170d3234303331383035333234385a180f32313234303232333035333234385a306b310b3009060355040613024455310f300d06035504080c0644756d6d7932310f300d06035504070c0644756d6d7932310f300d060355040a0c0644756d6d7932310f300d060355040b0c0644756d6d79323118301606035504030c0f44756d6d79204c6561662043657274308201a2300d06092a864886f70d01010105000382018f003082018a0282018100b2585d4aebdeba2ad3aabf56cb6797cd9cf1c8c04fcadfbf67909b1b045064f29e09c1e0650061dcaeeb679f75a2c9ee29724ac77ae26e3c4241b7d6bcfcf1d2c6d27c6aada87484c1aaf292cdbb191d61e18768a3cffc926492caaba67af4777acad09a272f494735ecfcd1111153cac8ee309be5717482ffd3fb598da6a5468f340ef98e3a9f3e120946985d2a0007a2966042b563751ec9bb131c46d0bebc8f4d0c97bc748d763d2fedf91e285e81d71a9f178f312306d83ab42b009d2f9a8001d09a57902994eca1e10087e4f77725bdd9def0d8b679b0d52518767175462cf1765eb78452895170c10fc3faa32faf9c6febc578cc001c43b564c6ea675ccddbe56335c7082021656a2f8d35719c289bdd7810914a525e706da9c5914ca937a848b4fd7e1e720e84f3c683bd3eb6c0dce95b9264b2a56f4637bf30d0e19616c7fa7d264e84cca8a0526761cf19bc8bbeb85b00fee954881cc60afe62592a41faa83e5f4d1687c0f1a1a979cd707a35407736ee97907ae554ed8799a9d1f70203010001a36f306d302b0603551d1f042430223020a01ea01c861a687474703a2f2f6578616d706c652e636f6d2f63726c2e70656d301d0603551d0e04160414527ff10a71a7ee2b74a48d4592da9b09bfbdf955301f0603551d2304183016801438f50c1abe88224ec74c20a99a63b745d20d64bd300d06092a864886f70d01010b0500038201810089f3ae2093b91696893de886fdaa5dffc30eb18dfadab8409861705dd0c11d34207ca59f5bfdcc8105025e66baadb0beea394147751294d848d17f16e82c5ccff7333acaf31d9587955e39a12454b5ca45c3a6458f96ad558493af19ed0ca95fa101f14f2d185988c4d1823476e038ff1321a4189cba9117da90044d97a93ee955154f63a09285030b9fff458311116dfed6a563f272b9a594df65093b0df772a147972cfd89a50aa39853a1db9abca74db5b43ed697647b4cdfde5964066a0f349fc4de3e7ddd3b883c3d37c1e246e6ddeddf60732b0ddd5e0226752555a00d735ea0f91c0c6b19119a64c09498428e2f6283ceb895e3c655ed109378476bb130d94385cf320dec5cb229257ea5bec8f32b586467b31e5359ee47a46155a48b499bb238dd7e70b85191fcd30e3fd18176444cba854593a03ab4b9341419572d6392e7d5c787849bb0391015160d69642452a72f4359e9ff4b347a720d5e76450b0332cb2b4d7846c3f0228ca405f7de8152f1d1c5251ef031b40542e0745ad9";
	        validInterCaCertHex = "308204d73082033fa003020102021463a683807d42276ea51d7e3c540fad9c4d7e45dc300d06092a864886f70d01010b05003065310b3009060355040613024455310e300c06035504080c0544756d6d79310e300c06035504070c0544756d6d79310e300c060355040a0c0544756d6d79310e300c060355040b0c0544756d6d793116301406035504030c0d44756d6d7920526f6f742043413020170d3234303331383035323934325a180f32313234303232333035323934325a3073310b3009060355040613024455310f300d06035504080c0644756d6d7931310f300d06035504070c0644756d6d7931310f300d060355040a0c0644756d6d7931310f300d060355040b0c0644756d6d79313120301e06035504030c1744756d6d7920496e7465726d6564696174652043657274308201a2300d06092a864886f70d01010105000382018f003082018a02820181009c8ca3868ca73aa0a106507c27811e1733e0b4acdc105d3209ae2ac0f0db8bb5f790f39506577aa9940ad001f1051886b5d9ecd9761f1adb519173b23b5964387cd30bd5263177bdd6b576b978e80dd5d56f8235fad38bda81146c09648044ae22d8f3394599304970dfe3d455a6ccb6412802a625daa3ed0a4c2a44d225a18b845eb0446491c3b32434dd8f41bfba69772a643807eefef08c4b23d4a6f822699cb2467afd4a1a3ed5147a6c1992864f284339a646132b7972e1a922f7904db7ea7356afeaf1d2a5b8cdcca297afa6fe75adc0a54ac7ac59cdd3761524124c35240e0ea57d1357de683fbb931b1434f49ad36fd39fa7c07d2ca934d6b578f71d621adcaaf6f8de92d3e5219f303a917576140951e07409644d964ecc4cba0b02f5a789e350705abdfd69b23a84bb69ae778297e78e6b49428a479e4ea5e27409100ec4cb484ef076b9ea2ed2f1e28078008c430d37807a5c94b4bdcc9453a119b2919edfc482c7f43c1ee974d3549ff919c1d20fdcbb3d953a381ed109cd5fc70203010001a36f306d302b0603551d1f042430223020a01ea01c861a687474703a2f2f6578616d706c652e636f6d2f63726c2e70656d301d0603551d0e0416041438f50c1abe88224ec74c20a99a63b745d20d64bd301f0603551d23041830168014dfafb758f63684ecf2e5175d9e30dad74f0e4e1c300d06092a864886f70d01010b050003820181000bd77ca87914254630847b3e57e2de4c83ff461f8e7cbe343bed850a378e626e01716be1a91a5dcf132174cd7a367905a44168008576f38efb86e6a93ec8da6374812e7de84e232f4ecf9a78e885e49794a8754e090bf3a751af5eea542c758f01d778a0621ea9fe9866c05ef22d76d89087d08a125a8cb862a73d7ebd5a401d7001ed45660f37162968840c02c384feeed630b8bfcd611691a6da6c6370243e23afc3fdc138f017d68922226918c41f4de7bb3ef1cf07862d6e4b5882d8d02a0f21c59397243e060030c73ee18c75f70398d17eb4dec8ef607e49d3f184e4884a29d8e9d47157460a3822e62f365c26f680c316a15498d99202bfbe7f05f08fc37bc8c324c5f550f513f529822ae65178d839c4dabb3446ba6fadfc088862760ecef301b26162c31521781f85b641db6ccc93fa7beea2f69a5ba773a74202b4059d09f75bedc6bacb3b1344c0aabac1a75e5209211204561e733c7657f2cea1ee68db910725778c13978afabd72fa831cc3230d9a82ca7be040dd2bbe5b78c6";
            outdatedCrlHex = "308202733082019BA00302010202101A33F17D9823D118C740AC0D300D06092A864886F70D0101050500307D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464301E170D3230303430313030303030305A170D3230303430343132303030305A307D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464308181310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C7464304D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C746430819F300D06092A864886F70D010101050003818D0030818902818100B93D383F609DE79C2C9F0C2A49C1FAED7F84C97EEA4ADBA9D1CE53D847CDC1564899F36B0502C81BFD8ABD0D0517D1C140D0572D79A4E38C4A0F0D362E17A119E36011C12C36249E0F9D8D617352A882C5A28C3C8A1F01A8D0991C78FB7D3B9973B756C0B0D8D7B5EAE704831E72195D3A3FBEB1449E7D50F5202010001300D06092A864886F70D010105050030818D310B3009060355040613025553311330110603550408130A57617368696E67746F6E3110300E060355040713075265766F6B65311F301D060355040A0C165265766F6B652050726F7669646572204C746430819F300D06092A864886F70D010101050003818D0030818902818100B93D383F609DE79C2C9F0C2A49C1FAED7F84C97EEA4ADBA9D1CE53D847CDC1564899F36B0502C81BFD8ABD0D0517D1C140D0572D79A4E38C4A0F0D362E17A119E36011C12C36249E0F9D8D617352A882C5A28C3C8A1F01A8D0991C78FB7D3B9973B756C0B0D8D7B5EAE704831E72195D3A3FBEB1449E7D50F5202010001300D06092A864886F70D0101050500";
            certNoDistributionPoints = "-----BEGIN CERTIFICATE-----\nMIIDwTCCAqmgAwIBAgIgbVqgQF+vioHzCJNn3ui4+hyQyu1+9P0IHlglQFPKUbUw\nDQYJKoZIhvcNAQEFBQAwdjEOMAwGA1UEBhMFQmxvcmUxDTALBgNVBAoMBElOVEMx\nDTALBgNVBAsMBElOVEMxEjAQBgNVBAMMCWR1bW15LmNvbTEeMBwGCSqGSIb3DQEJ\nARYPZHVtbXlAZHVtbXkuY29tMRIwEAYDVQQDDAlkdW1teS5jb20wHhcNMjQwMjA3\nMDUxNDM1WhcNMzQwMjA3MDUxNDM1WjBiMQ4wDAYDVQQGEwVCbG9yZTENMAsGA1UE\nCgwESU5UQzENMAsGA1UECwwESU5UQzESMBAGA1UEAwwJZHVtbXkuY29tMR4wHAYJ\nKoZIhvcNAQkBFg9kdW1teUBkdW1teS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCSx0idbSH3MycmDgbcQuI/6LRRIcdpNnvLLTLHU0sRz63J3sYX\nSX/gF0UgAFocZlZAny69t7RJ9N7wvQ6jUMTjvKjdqxXEzmNf9gjS38t8cB5ikRAm\nC+3Xt5fBLy1XzvrjUFVBcevUw+Y+oJ0clLknHNCVJTKLkQPxRHUleVaV3wC5YB7R\nF+XQVfUsu3mJzRrA13WGjtF2KmLsgaEX/SuCHi0QcGBapo8U8y8y3gV72DEpqIVx\nigl+iduxlhNQAaUMiD6WPs0jAVc1cP8ah+jq/+U9SJ5Bp7faMiThGsxmm8oVvOD5\nZw5DeCFfy8sSTI98IlHsOqBnk8w1tXQpUCbTAgMBAAGjTzBNMB0GA1UdDgQWBBT4\n156vh9jLxF0z631dkgTUMtKYnTAfBgNVHSMEGDAWgBT4156vh9jLxF0z631dkgTU\nMtKYnTALBgNVHREEBDACggAwDQYJKoZIhvcNAQEFBQADggEBAI/B3SbP4s9gTiMj\nSyvXpgvZVpYX+HH5rIptOylgD4xSVgBIFUP7G1barfUS6ClackCfrmRso9WmO45N\nPSgDe4R0QPEOthIAmy3or0tGGjaj35TRzaWDfgQLIa1mB3hmLXpMWppf5FY3sPjs\noLQVHW+KwQPyWNZl8u2CjSyzj8PaAa3rJqCIlQDp+UsWH8UhOIAogU53HFpNaWYT\nEnnN7+U5TmCKxi3ciksXq9GZ0cOz3WBo0L2/GQjz56rQUv8jVb5KmJ6h2M9EKXOE\nxe18NNZB0qaBTFpboNmWWmbe67/NupWEQmHHgjRiy7MlnvTsrFXdl3f/Y2qhvri/\nKW43J1c=\n-----END CERTIFICATE-----";

            // jwks samples for testing
            validJwks = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            invalidJwks = "{\"keys\":[{\"kty\":\"RSA\",\"kid\":\"example-key-1\",\"use\":\"sig\",\"alg\":\"RS512\",\"n\":\"p7-56CwfyqLldDQ7d0C0ZFQTL2e9mz_1iHbBTV6p4I8R2tlqsh4DVdS6ilxf_FWe_HlnXq1Nkx-_z1miSZhRg_kHPjtbcvxGRoKBKqBcXhUdVY7xFsD9m6W6z6h9dN6OXJ0NQY0DzGtmRTD_yuQFgYUn8KosdREH-Pp8w-fgfr3r5Q\",\"e\":\"AQAB\",\"d\":\"G3psHvef3HzarQUGryEP4kP8x8nOh9GfM2R8YOTsKpyY9aYtHxFuiPks8fvW8RyyPDTnzZ-_6RUvZYN3WEDF0Y-XbwrlM78KmmhYtEvQajOhLprW4W4hJpxITf1qOxgjA62RVa1Op2_A2LDRj7XqfZ9JoPB0IlnugBx9OuP7_kFmE\",\"p\":\"_qkjLJlRg_ZXr9ifM3URrTD00mVW8U35s5RZWdhEmy9eGU7mjQjsoiVif3nquV7BrzETXyH5UdH9xxV2yjprHw\",\"q\":\"xlqm_LueqqOQBWx-3VlbiqQs47ShJ7xwANU2cvh9eNifnJWOTlnqHLW-k9wZJnXCZSM3p1JQXgtN7lfcgGRI5Ww\",\"dp\":\"PnIInZSoMltzLy3YyNL0s4F8v33EhRO3KW9rsy5sfiC-3DpSszCwFvF3KH4RpN5y2efR4iaCk7NKId24qARh8w\",\"dq\":\"JF8-9bRfb9mYERQYdOi-ALQDn4pVN84Fv0FhJhBqE5myaY6smhxQGw-o0m6yxCz3rpX_2tQ2R-2vxcrvdbEuyQ\",\"qi\":\"RSBFDqKwnF16Ig56pUP02xUw6fKLhU13rGf9Lh3K0gGZ4M9Jufc4sZKyL9ZgNdtfNUvHrL4d6IbY99Y6mI9JpQ\"}]}";
            leafVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            intermediateVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";
            rootVerificationFailureJWKS = "{\"keys\":[{\"alg\":\"PS384\",\"e\":\"AQAB\",\"kid\":\"1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59\",\"kty\":\"RSA\",\"n\":\"vKKV7v7czOHapQ22ZnW677i4BkQIuxVTLk933javfZyLzpM7ZP_Mhvu9QqHrr-iKEqCDBuX1slL_hoB0fTCGGnoFTZ1lTqBdmhFysIgg5uzAqMWL2SJdzYX9RJ_ZXMFnvzTznO-b2jJd864pUI6y72mrzfTqQvgw_60fa3tjc9zjJPiqT1yadKar3G5c0fJqg7AUooTuMkIq291tHqoNhfYzzshZCSFV_d5RruheVMjvgMunx1zISiZ5RNRjcy39G7-08UTCIlSKE_GdsLDNViHqACz60BW3p-kSY5YdoslwKvDUOJnkVZMpJNfdYDoBIiIGgKL2j5H8arHmhSw1A1kl66YdDl7H5Pa46qp4B2FrS5Qpt1D9C-SZXkWN3wzDIQLsHKs0e86R5guLMS9_WcfsPCcHCLjqMZe6S-18SdjwzCK4hbn5vLCZYUzIyVEIcYT8f3mS3s3I1UxJRW53WZOEKkyGVKKGTF8uRxaksFVGrIdW0Q41Wo3mB30N2tqL\",\"x5c\":[\"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\"]}]}";

            // kid to be extracted for testing the JWKS related functionalities
            kid = "1a1a2fe5fcf89009e4b96c45e0dceb005ea635d8ba2f6ed9caeef44ae235970decc586154fd9f740fb3b72ca176abb59";
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @After
    public void tearDown() {
        // Shut down Mock Server after tests are run
        mockServer.stop();
    }

    @Test
    public void testConstants() {
        assertEquals(Constants.HEADER_X_API_KEY, "x-api-key");
        assertEquals(Constants.HEADER_ACCEPT, "Accept");
        assertEquals(Constants.HEADER_CONTENT_TYPE, "Content-Type");
        assertEquals(Constants.HEADER_REQUEST_ID, "request-id");
        assertEquals(Constants.HEADER_TRACE_ID, "trace-id");
        assertEquals(Constants.MIME_APPLICATION_JSON, "application/json");
    }

    @Test
    public void testConfig() {
        try {
            // Default RetryConfig
            RetryConfig retryConfig = new RetryConfig(0, 0, 0);

            // Initialize config
            Config config = new Config("http://localhost:" + mockServer.getPort(),
                                       "http://localhost:" + mockServer.getPort(),
                                       "some_key",
                                       retryConfig);
            assertNotNull(config);

            // Test connector config setter
            TrustAuthorityConnector conn = new TrustAuthorityConnector(config);
            conn.setConfig(config);
            assertEquals(conn.getConfig(), config);

            // Testing getters for Config
            assertEquals(config.getBaseUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiKey(), "some_key");

            // Testing setters for Config
            config.setBaseUrl("http://localhost:" + mockServer.getPort());
            config.setApiUrl("http://localhost:" + mockServer.getPort());
            config.setApiKey("some_key");
            assertEquals(config.getBaseUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiUrl(), "http://localhost:" + mockServer.getPort());
            assertEquals(config.getApiKey(), "some_key");

            // Testing getters/setters for RetryConfig
            RetryConfig customRetryConfig = new RetryConfig(2, 10, 3);
            config.setRetryConfig(customRetryConfig);
            config.getRetryConfig().setRetryWaitMin(2);
            config.getRetryConfig().setRetryWaitMax(10);
            config.getRetryConfig().setRetryMax(3);
            assertEquals(config.getRetryConfig().getRetryWaitMin(), 2);
            assertEquals(config.getRetryConfig().getRetryWaitMax(), 10);
            assertEquals(config.getRetryConfig().getRetryMax(), 3);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testTokenRequest() {
        try {
            // Create mock objects for testing
            byte[] expected = {1, 2, 3, 4, 5};
            byte[] actual = {1, 2, 3, 4, 5};
            String expectedTokenSigningAlg = "mock-token-signing-algo";
            boolean expectedPolicyMustMatch = false;
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Initialize TokenRequest
            TokenRequest token_request = new TokenRequest(expected, mockNonce, expected, expected, mockPolicyIDs, expected, expectedTokenSigningAlg, expectedPolicyMustMatch);

            // Testing setters for TokenRequest
            token_request.setQuote(expected);
            token_request.setVerifierNonce(mockNonce);
            token_request.setRuntimeData(expected);
            token_request.setPolicyIds(mockPolicyIDs);
            token_request.setEventLog(expected);
            token_request.setTokenSigningAlg(expectedTokenSigningAlg);
            token_request.setPolicyMustMatch(expectedPolicyMustMatch);
            assertArrayEquals(token_request.getQuote(), actual);
            assertEquals(token_request.getVerifierNonce(), mockNonce);
            assertArrayEquals(token_request.getRuntimeData(), actual);
            assertEquals(token_request.getPolicyIds(), mockPolicyIDs);
            assertArrayEquals(token_request.getEventLog(), actual);
            assertEquals(token_request.getTokenSigningAlg(), expectedTokenSigningAlg);
            assertEquals(token_request.getPolicyMustMatch(), expectedPolicyMustMatch);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testEvidence() {
        try {
            // Create mock objects for testing
            byte[] expected = {1, 2, 3, 4, 5};
            byte[] actual = {1, 2, 3, 4, 5};

            // Initialize Evidence
            Evidence evidence = new Evidence(EvidenceType.SGX, expected, expected, expected, expected);

            // Testing getters for Evidence
            assertEquals(evidence.getType().ordinal(), 0);
            assertArrayEquals(evidence.getQuote(), actual);
            assertArrayEquals(evidence.getUserData(), actual);
            assertArrayEquals(evidence.getEventLog(), actual);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetNonce() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce_args for GetNonce() API
            GetNonceArgs nonce_args = new GetNonceArgs("mock-request-id");
            assertNotNull(nonce_args);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Calling the GetNonce() API
            GetNonceResponse nonceResponse = connector.GetNonce(nonce_args);

            // Verify response is not empty
            assertNotNull(nonceResponse);
            assertNotNull(nonceResponse.getNonce());

            // Convert nonce values to Base64 decoded bytes
            byte[] decodedBytesVal = Base64.from(nonce_val).decode();
            byte[] decodedBytesIat = Base64.from(nonce_iat).decode();
            byte[] decodedBytesSignature = Base64.from(nonce_signature).decode();

            // Verify the response
            assertArrayEquals(decodedBytesVal, nonceResponse.getNonce().getVal());
            assertArrayEquals(decodedBytesIat, nonceResponse.getNonce().getIat());
            assertArrayEquals(decodedBytesSignature, nonceResponse.getNonce().getSignature());
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetNonceFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce_args for GetNonce() API
            GetNonceArgs nonce_args = new GetNonceArgs(null);
            assertNotNull(nonce_args);

            // Stubbing the response with an invalid nonce
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_nonce"));

            // Calling the GetNonce() API
            GetNonceResponse nonceResponse = connector.GetNonce(nonce_args);
            assertNull(nonceResponse);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetToken() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Create a mock GetTokenArgs object
            GetTokenArgs mockArgs = mock(GetTokenArgs.class);
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            Evidence mockEvidence = mock(Evidence.class);
            when(mockEvidence.getType()).thenReturn(EvidenceType.SGX);
            when(mockArgs.getNonce()).thenReturn(mockNonce);
            when(mockArgs.getEvidence()).thenReturn(mockEvidence);
            when(mockArgs.getPolicyIds()).thenReturn(Arrays.asList(UUID.randomUUID()));
            when(mockArgs.getRequestId()).thenReturn("mock-request-id");

            // Sample token to be sent from server
            String token = "mock-token";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"token\":\"" + token + "\"}"));

            // Calling the GetToken() API
            GetTokenResponse tokenResponse = connector.GetToken(mockArgs);
            assertNotNull(tokenResponse);

            // Verify the response
            assertEquals("mock-token", tokenResponse.getToken());

            // Test GetTokenResponse creation
            Map<String, List<String>> mockHeaders = mock(Map.class);
            GetTokenResponse testTokenResponse = new GetTokenResponse(token, mockHeaders);
            assertNotNull(testTokenResponse);
            assertEquals(testTokenResponse.getToken(), token);
            assertEquals(testTokenResponse.getHeaders(), mockHeaders);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetTokenFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Create a mock GetTokenArgs object
            GetTokenArgs mockArgs = mock(GetTokenArgs.class);
            VerifierNonce mockNonce = new VerifierNonce("mock-val".getBytes(), "mock-iat".getBytes(), "mock-signature".getBytes());
            Evidence mockEvidence = mock(Evidence.class);
            when(mockArgs.getNonce()).thenReturn(mockNonce);
            when(mockArgs.getEvidence()).thenReturn(mockEvidence);
            when(mockArgs.getPolicyIds()).thenReturn(Arrays.asList(UUID.randomUUID()));
            when(mockArgs.getRequestId()).thenReturn(null);

            // Stubbing the response with an invalid token and
            // response code 503 to exercise doRequest() retry
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(503)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_token"));

            // Calling the GetToken() API
            GetTokenResponse tokenResponse = connector.GetToken(mockArgs);
            assertNull(tokenResponse);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testAttest() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Sample token to be sent from server
            String token = "mock-token";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"token\":\"" + token + "\"}"));

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockEvidence.getType()).thenReturn(EvidenceType.SGX);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Sample requestID
            String expectedRequestID = "mock-request-id";

            // Sample token-signing-algo
            String expectedTokenSigningAlg = "mock-token-signing-algo";

            // Sample policy-must-match
            boolean expectedPolicyMustMatch = false;

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, expectedRequestID, expectedTokenSigningAlg, expectedPolicyMustMatch);

            AttestResponse response = connector.attest(attestArgs);

            // Verify the response
            assertNotNull(response);
            assertEquals(response.getToken(), "mock-token");
            assertNotNull(response.getHeaders());

            // Test setters/getters
            attestArgs.setRequestId(expectedRequestID);
            attestArgs.setPolicyIds(mockPolicyIDs);
            attestArgs.setAdapter(mockAdapter);
            attestArgs.setTokenSigningAlg(expectedTokenSigningAlg);
            attestArgs.setPolicyMustMatch(expectedPolicyMustMatch);
            assertEquals(attestArgs.getRequestId(), expectedRequestID);
            assertEquals(attestArgs.getPolicyIds(), mockPolicyIDs);
            assertEquals(attestArgs.getAdapter(), mockAdapter);
            assertEquals(attestArgs.getTokenSigningAlg(), expectedTokenSigningAlg);
            assertEquals(attestArgs.getPolicyMustMatch(), expectedPolicyMustMatch);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testAttestNonceFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response with an invalid nonce
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_nonce"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, "mock-request-id", "mock-token-signing-algo", false);
            AttestResponse response = connector.attest(attestArgs);
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testAttestTokenFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Initialize nonce values for serving from mock server
            String nonce_val = "MjAyMy0xMi0yMCAxNzo0MDowNiArMDAwMCBVVEM=";
            String nonce_iat = "MjAyMi0wOC0yNCAxMjozNjozMi45Mjk3MjIwNzUgKzAwMDAgVVRD";
            String nonce_signature = "g9QC7VxV0n8dID0zSJeVLSULqYCJuv4iMepby91xukrhXgKrKscGXB5lxmT2s3POjxVOG+fSPCYpOKYWRRWAyQ==";

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/nonce"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"val\":\"" + nonce_val + "\",\"iat\":\"" + nonce_iat + "\",\"signature\":\"" + nonce_signature + "\"}"));

            // Stubbing the response with an invalid token
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/appraisal/v1/attest"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_token"));

            // Create a mock Evidence object
            Evidence mockEvidence = mock(Evidence.class);

            // Create a mock PolicyIDs object
            List<UUID> mockPolicyIDs = Arrays.asList(UUID.randomUUID());

            // Create a mock adapter object
            EvidenceAdapter mockAdapter = mock(EvidenceAdapter.class);
            when(mockAdapter.collectEvidence(any())).thenReturn(mockEvidence);

            // Perform the test
            AttestArgs attestArgs = new AttestArgs(mockAdapter, mockPolicyIDs, "mock-request-id", "mock-token-signing-algo", false);
            AttestResponse response = connector.attest(attestArgs);
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetTokenSigningCertificates() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{\"keys\":[{\"kty\":\"RSA\",\"n\":\"u1SU1LfVLPHCozMxH2Mo4lgOEePzNm0tRgeLezV6ffAt0gunVTLw7onLRnrq0/IzW7yWR7QkrmBL7jTKEn5u+qKhbwKfBstIs+bMY2Zkp18gnTxKLxoS2tFczGkPLPgizskuemMghRniWaoLcyehkd3qqGElvW/VDL5AaWTg0nLVkjRo9z+40RQzuVaE8AkAFmxZzow3x+VJYKdjykkJ0iT9wCS0DRTXu269V264Vf/3jvredZiKRkgwlL9xNAwxXFg0x/XFw005UWVRIkdgcKWTjpBP2dPwVZ4WWC+9aGVd+Gyn1o0CLelf4rEjGoXbAAEgAqeGUxrcIlbjXfbcmw==\",\"e\":\"AQAB\",\"alg\":\"PS384\",\"x5c\":[\"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\"],\"kid\":\"12345\"}]}"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNotNull(response);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetTokenSigningCertificatesFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response and induce a failure response code 404
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(404)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("Not Found"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testOpenConnectionWithRetries() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response and induce a response code 503 to exercise retry mechanism
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(503)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("hello-world"));

            // Calling the getTokenSigningCertificates() API
            String response = connector.getTokenSigningCertificates();
            assertNull(response);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidToken() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid token
            JWTClaimsSet invalidClaims = connector.verifyToken(invalidToken);
            assertNull(invalidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenMissingKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with missing Kid token
            JWTClaimsSet missingKidClaims = connector.verifyToken(tokenMissingKid);
            assertNull(missingKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid Kid token
            JWTClaimsSet invalidKidClaims = connector.verifyToken(tokenInvalidKid);
            assertNull(invalidKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenWrongKid() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with wrong Kid token
            JWTClaimsSet wrongKidClaims = connector.verifyToken(tokenWrongKid);
            assertNull(wrongKidClaims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenMalformedJwks() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("invalid_jwks"));

            // Calling the verifyToken() API with valid token
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenJwksNoKeys() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody("{ \"keys\": [] }"));

            // Calling the verifyToken() API with valid token
            // and jwks with no keys
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidJwks() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(invalidJwks));

            // Calling the verifyToken() API with valid token
            // wrong jwks with verification failure
            JWTClaimsSet claims = connector.verifyToken(validToken);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyTokenInvalidJwtAlgorithm() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/certs"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(validJwks));

            // Calling the verifyToken() API with invalid algo token
            JWTClaimsSet claims = connector.verifyToken(tokenInvalidAlg);
            assertNull(claims);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLEmptyURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Calling the getCRL() API with empty string
            X509CRL crl = connector.getCRL(null);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLInvalidURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = ":trustauthority.intel.com";

            // Calling the getCRL() API with invalid string
            X509CRL crl = connector.getCRL(crlUrl);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLValidURL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = cfg.getBaseUrl() + "/ats-ca-crl.der";

            // Convert Crl from hex to bytes
            byte[] CrlBytes = hexStringToByteArray(crlHex);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/ats-ca-crl.der"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(CrlBytes));

            X509CRL crl = connector.getCRL(crlUrl);
            assertNotNull(crl);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetCRLInvalidCRL() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            String crlUrl = cfg.getBaseUrl() + "/ats-ca-crl.der";

            // Convert Crl from hex to bytes
            byte[] invalidCertBytes = hexStringToByteArray(invalidCertHex);

            // Stubbing the response
            new MockServerClient("localhost", mockServer.getPort())
                                .when(HttpRequest.request().withPath("/ats-ca-crl.der"))
                                .respond(HttpResponse.response().withStatusCode(200)
                                .withHeader(Constants.HEADER_ACCEPT, Constants.MIME_APPLICATION_JSON)
                                .withBody(invalidCertBytes));

            X509CRL crl = connector.getCRL(crlUrl);
            assertNull(crl);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLEmptyCerts() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            X509Certificate leafCertificate = null;
            X509Certificate intermediateCertificate = null;

            // Calling the getCRL() API with empty string
            boolean verified = connector.verifyCRL(null, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLValidCertAndCrl() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(validInterCaCertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from crlHex
            byte[] CrlBytes = hexStringToByteArray(crlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(CrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertTrue(verified);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testVerifyCRLInvalidCACert() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(invalidCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(invalidCACertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from crlHex
            byte[] CrlBytes = hexStringToByteArray(crlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(CrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCRLOutdatedCrl() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Convert hex string to X509Certificate
            byte[] intermediateCertBytes = hexStringToByteArray(validInterCaCertHex);
            X509Certificate intermediateCertificate = (X509Certificate) CertificateFactory
                                                        .getInstance("X.509")
                                                        .generateCertificate(new ByteArrayInputStream(intermediateCertBytes));

            // Create X509CRL crl from outdatedCrlHex
            byte[] outdatedCrlBytes = hexStringToByteArray(outdatedCrlHex);
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(outdatedCrlBytes));

            // Calling the verifyCRL() API
            boolean verified = connector.verifyCRL(crl, leafCertificate, intermediateCertificate);
            assertFalse(verified);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testGetCRLDistributionPoints() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert hex string to X509Certificate
            byte[] certBytes = hexStringToByteArray(validCertHex);
            X509Certificate leafCertificate = (X509Certificate) CertificateFactory
                                                .getInstance("X.509")
                                                .generateCertificate(new ByteArrayInputStream(certBytes));

            // Testing getCRLDistributionPoints() function
            List<String> listcrlDistributionPointsUriLeafCert = connector.getCRLDistributionPoints(leafCertificate);
            assertNotNull(listcrlDistributionPointsUriLeafCert);
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testGetCRLDistributionPointsFailure() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Convert string to X509Certificate
            X509Certificate certificate = (X509Certificate) CertificateFactory
                                            .getInstance("X.509")
                                            .generateCertificate(new ByteArrayInputStream(certNoDistributionPoints.getBytes()));

            // Testing getCRLDistributionPoints() function
            List<String> listcrlDistributionPointsUriLeafCert = connector.getCRLDistributionPoints(certificate);
            assertNull(listcrlDistributionPointsUriLeafCert);
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChain() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(validJwks);
            
            JWK jwkKey = jwkSet.getKeyByKeyId(kid);
            if (jwkKey == null) {
                throw new Exception("Could not find Key matching the key id");
            }

            // Retrieve the X.509 certificates
            List<X509Certificate> certificates = jwkKey.getParsedX509CertChain();

            // Verify the certificate chain
            if (!connector.verifyCertificateChain(certificates)) {
                throw new Exception("Certificate chain verification failed");
            }
        } catch (Exception e) {
            // Fail the test explicitly in the catch block
            Assert.fail("Exception: " + e.getMessage());
        }
    }

    @Test
    public void testVerifyCertificateChainWrongLeafCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(leafVerificationFailureJWKS);

            JWK jwkKey = jwkSet.getKeyByKeyId(kid);
            if (jwkKey == null) {
                throw new Exception("Could not find Key matching the key id");
            }

            // Retrieve the X.509 certificates
            List<X509Certificate> certificates = jwkKey.getParsedX509CertChain();

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChainWrongInterCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(intermediateVerificationFailureJWKS);

            JWK jwkKey = jwkSet.getKeyByKeyId(kid);
            if (jwkKey == null) {
                throw new Exception("Could not find Key matching the key id");
            }

            // Retrieve the X.509 certificates
            List<X509Certificate> certificates = jwkKey.getParsedX509CertChain();

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    @Test
    public void testVerifyCertificateChainWrongRootCA() {
        try {
            // Check if config is not null
            assertNotNull(cfg);

            // Check if connector is not null
            assertNotNull(connector);

            // Parse the JWKS
            JWKSet jwkSet = JWKSet.parse(rootVerificationFailureJWKS);

            JWK jwkKey = jwkSet.getKeyByKeyId(kid);
            if (jwkKey == null) {
                throw new Exception("Could not find Key matching the key id");
            }

            // Retrieve the X.509 certificates
            List<X509Certificate> certificates = jwkKey.getParsedX509CertChain();

            // Verify the certificate chain
            assertFalse(connector.verifyCertificateChain(certificates));
        } catch (Exception e) {
            // Ignore exceptions as they are expected in failure conditions
        }
    }

    /**
     * Helper function to convert hex string to byte[]
     *
     * @param hexString   hex string
     * @return            byte[] object of hex string
     */
    private byte[] hexStringToByteArray(String hexString) {
        int len = hexString.length();
        byte[] data = new byte[len / 2];

        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4)
                                 + Character.digit(hexString.charAt(i + 1), 16));
        }

        return data;
    }
}